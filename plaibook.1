#reader(lib"read.ss""wxme")WXME0108 ## 
#|
   This file uses the GRacket editor format.
   Open this file in DrRacket version 5.3.3 or later to read it.

   Most likely, it was created by saving a program in DrRacket,
   and it probably contains a program with non-text elements
   (such as images or comment boxes).

            http://racket-lang.org/
|#
 30 7 #"wxtext\0"
3 1 6 #"wxtab\0"
1 1 8 #"wximage\0"
2 0 8 #"wxmedia\0"
4 1 34 #"(lib \"syntax-browser.ss\" \"mrlib\")\0"
1 0 16 #"drscheme:number\0"
3 0 44 #"(lib \"number-snip.ss\" \"drscheme\" \"private\")\0"
1 0 36 #"(lib \"comment-snip.ss\" \"framework\")\0"
1 0 93
(
 #"((lib \"collapsed-snipclass.ss\" \"framework\") (lib \"collapsed-sni"
 #"pclass-wxme.ss\" \"framework\"))\0"
) 0 0 43 #"(lib \"collapsed-snipclass.ss\" \"framework\")\0"
0 0 19 #"drscheme:sexp-snip\0"
0 0 36 #"(lib \"cache-image-snip.ss\" \"mrlib\")\0"
1 0 68
(
 #"((lib \"image-core.ss\" \"mrlib\") (lib \"image-core-wxme.rkt\" \"mr"
 #"lib\"))\0"
) 1 0 29 #"drscheme:bindings-snipclass%\0"
1 0 88
(
 #"((lib \"pict-snip.rkt\" \"drracket\" \"private\") (lib \"pict-snip.r"
 #"kt\" \"drracket\" \"private\"))\0"
) 0 0 33 #"(lib \"bullet-snip.ss\" \"browser\")\0"
0 0 25 #"(lib \"matrix.ss\" \"htdp\")\0"
1 0 22 #"drscheme:lambda-snip%\0"
1 0 26 #"drracket:spacer-snipclass\0"
0 0 57
#"(lib \"hrule-snip.rkt\" \"macro-debugger\" \"syntax-browser\")\0"
1 0 26 #"drscheme:pict-value-snip%\0"
0 0 45 #"(lib \"image-snipr.ss\" \"slideshow\" \"private\")\0"
1 0 38 #"(lib \"pict-snipclass.ss\" \"slideshow\")\0"
2 0 55 #"(lib \"vertical-separator-snip.ss\" \"stepper\" \"private\")\0"
1 0 18 #"drscheme:xml-snip\0"
1 0 31 #"(lib \"xml-snipclass.ss\" \"xml\")\0"
1 0 21 #"drscheme:scheme-snip\0"
2 0 34 #"(lib \"scheme-snipclass.ss\" \"xml\")\0"
1 0 10 #"text-box%\0"
1 0 32 #"(lib \"text-snipclass.ss\" \"xml\")\0"
1 0 1 6 #"wxloc\0"
          0 0 57 0 1 #"\0"
0 75 1 #"\0"
0 10 90 -1 90 -1 3 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 255 255 255 1 -1 0 9
#"Standard\0"
0 75 12 #"Courier New\0"
0 10 90 -1 90 -1 3 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 255 255 255 1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0 -1 -1 2 24
#"framework:default-color\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 150 0 150 0 0 0 -1 -1 2 15
#"text:ports out\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 150 0 150 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1.0 0 -1 -1 93 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 255 0 0 0 0 0 -1
-1 2 15 #"text:ports err\0"
0 -1 1 #"\0"
1.0 0 -1 -1 93 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 255 0 0 0 0 0 -1
-1 2 1 #"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 175 0 0 0 -1 -1 2 17
#"text:ports value\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 175 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 34 139 34 0 0 0 -1
-1 2 27 #"Matching Parenthesis Style\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 34 139 34 0 0 0 -1
-1 2 1 #"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 37
#"framework:syntax-color:scheme:symbol\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 38
#"framework:syntax-color:scheme:keyword\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 194 116 31 0 0 0 -1 -1 2
38 #"framework:syntax-color:scheme:comment\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 194 116 31 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 37
#"framework:syntax-color:scheme:string\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 39
#"framework:syntax-color:scheme:constant\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 42
#"framework:syntax-color:scheme:parenthesis\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 36
#"framework:syntax-color:scheme:error\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 36
#"framework:syntax-color:scheme:other\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 16
#"Misspelled Text\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 81 112 203 0 0 0 -1 -1 2
38 #"drracket:check-syntax:lexically-bound\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 81 112 203 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 28
#"drracket:check-syntax:set!d\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 37
#"drracket:check-syntax:unused-require\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 36
#"drracket:check-syntax:free-variable\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 68 0 203 0 0 0 -1 -1 2 31
#"drracket:check-syntax:imported\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 68 0 203 0 0 0 -1 -1 2 47
#"drracket:check-syntax:my-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 116 0 0 0 0 -1 -1 2 50
#"drracket:check-syntax:their-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 116 0 0 0 0 -1 -1 2 48
#"drracket:check-syntax:unk-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 139 142 28 0 0 0 -1 -1 2
49 #"drracket:check-syntax:both-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 139 142 28 0 0 0 -1 -1 2
26 #"plt:htdp:test-coverage-on\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 2 27
#"plt:htdp:test-coverage-off\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 4 1
#"\0"
0 70 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 4 4 #"XML\0"
0 70 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 2 1 #"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 34 139 34 0 0 0 -1 -1 2 37
#"plt:module-language:test-coverage-on\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 34 139 34 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 176 48 96 0 0 0 -1 -1 2 38
#"plt:module-language:test-coverage-off\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 176 48 96 0 0 0 -1 -1 4 1
#"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 4 1 #"\0"
0 -1 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 1 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 0 255 0 0 0 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 1 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 0 255 0 0 0 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 100 0 0 0 0 -1
-1 2 1 #"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 200 0 0 0 0 0 -1 -1 4 1
#"\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 255 255 0 -1 -1
          0 2964 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 39 #";;; Chapter 12 Representation Decisions"
0 0 22 29 1 #"\n"
0 0 17 3 3 #";;;"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 17 3 24 #";; 12.4 One More Example"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 26 3 16 #"#lang plai-typed"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 22 3 1 #"("
0 0 15 3 11 #"define-type"
0 0 22 3 1 #" "
0 0 14 3 5 #"ExprC"
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ["
0 0 14 3 4 #"numC"
0 0 22 3 2 #" ("
0 0 14 3 1 #"n"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 6 #"number"
0 0 22 3 2 #")]"
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ["
0 0 14 3 3 #"idC"
0 0 22 3 2 #" ("
0 0 14 3 1 #"s"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 6 #"symbol"
0 0 22 3 2 #")]"
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ["
0 0 14 3 4 #"appC"
0 0 22 3 2 #" ("
0 0 14 3 1 #"f"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"ExprC"
0 0 22 3 3 #") ("
0 0 14 3 1 #"a"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"ExprC"
0 0 22 3 2 #")]"
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ["
0 0 14 3 5 #"plusC"
0 0 22 3 2 #" ("
0 0 14 3 1 #"l"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"ExprC"
0 0 22 3 3 #") ("
0 0 14 3 1 #"r"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"ExprC"
0 0 22 3 2 #")]"
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ["
0 0 14 3 5 #"multC"
0 0 22 3 2 #" ("
0 0 14 3 1 #"l"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"ExprC"
0 0 22 3 3 #") ("
0 0 14 3 1 #"r"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"ExprC"
0 0 22 3 2 #")]"
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ["
0 0 14 3 4 #"lamC"
0 0 22 3 2 #" ("
0 0 14 3 1 #"a"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 6 #"symbol"
0 0 22 3 3 #") ("
0 0 14 3 1 #"b"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"ExprC"
0 0 22 3 3 #")])"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 22 3 1 #"("
0 0 15 3 11 #"define-type"
0 0 22 3 1 #" "
0 0 14 3 5 #"Value"
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ["
0 0 14 3 4 #"numV"
0 0 22 3 2 #" ("
0 0 14 3 1 #"n"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 6 #"number"
0 0 22 3 2 #")]"
0 0 22 29 1 #"\n"
0 0 22 3 2 #"  "
0 0 17 3 2 #"#;"
0 0 22 3 1 #"["
0 0 14 3 5 #"closV"
0 0 22 3 2 #" ("
0 0 14 3 3 #"arg"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 6 #"symbol"
0 0 22 3 3 #") ("
0 0 14 3 4 #"body"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"ExprC"
0 0 22 3 3 #") ("
0 0 14 3 3 #"env"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 3 #"Env"
0 0 22 3 2 #")]"
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ["
0 0 14 3 5 #"closV"
0 0 22 3 2 #" ("
0 0 14 3 1 #"f"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 2 #" ("
0 0 14 3 5 #"Value"
0 0 22 3 1 #" "
0 0 14 3 2 #"->"
0 0 22 3 1 #" "
0 0 14 3 5 #"Value"
0 0 22 3 4 #"))])"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 22 3 1 #"("
0 0 15 3 11 #"define-type"
0 0 22 3 1 #" "
0 0 14 3 7 #"Binding"
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ["
0 0 14 3 4 #"bind"
0 0 22 3 2 #" ("
0 0 14 3 4 #"name"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 6 #"symbol"
0 0 22 3 3 #") ("
0 0 14 3 3 #"val"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"Value"
0 0 22 3 3 #")])"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 22 3 1 #"("
0 0 15 3 17 #"define-type-alias"
0 0 22 3 1 #" "
0 0 14 3 3 #"Env"
0 0 22 3 2 #" ("
0 0 14 3 6 #"symbol"
0 0 22 3 1 #" "
0 0 14 3 2 #"->"
0 0 22 3 1 #" "
0 0 14 3 5 #"Value"
0 0 22 3 2 #"))"
0 0 22 29 1 #"\n"
0 0 22 3 1 #"("
0 0 15 3 6 #"define"
0 0 22 3 2 #" ("
0 0 14 3 9 #"empty-env"
0 0 22 3 2 #" ["
0 0 14 3 4 #"name"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 6 #"symbol"
0 0 22 3 3 #"]) "
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ("
0 0 14 3 5 #"error"
0 0 22 3 1 #" "
0 0 20 3 1 #"'"
0 0 14 3 6 #"lookup"
0 0 22 3 1 #" "
0 0 19 3 16 #"\"name not found\""
0 0 22 3 3 #")) "
0 0 22 29 1 #"\n"
0 0 22 3 1 #"("
0 0 15 3 6 #"define"
0 0 22 3 2 #" ("
0 0 14 3 10 #"extend-env"
0 0 22 3 2 #" ["
0 0 14 3 1 #"b"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 7 #"Binding"
0 0 22 3 3 #"] ["
0 0 14 3 1 #"e"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 3 #"Env"
0 0 22 3 3 #"]) "
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 22 3 3 #" (["
0 0 14 3 4 #"name"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 6 #"symbol"
0 0 22 3 3 #"]) "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"Value"
0 0 22 3 1 #" "
0 0 22 29 1 #"\n"
0 0 22 3 5 #"    ("
0 0 14 3 2 #"if"
0 0 22 3 2 #" ("
0 0 14 3 8 #"symbol=?"
0 0 22 3 1 #" "
0 0 14 3 4 #"name"
0 0 22 3 2 #" ("
0 0 14 3 9 #"bind-name"
0 0 22 3 1 #" "
0 0 14 3 1 #"b"
0 0 22 3 3 #")) "
0 0 22 29 1 #"\n"
0 0 22 3 9 #"        ("
0 0 14 3 8 #"bind-val"
0 0 22 3 1 #" "
0 0 14 3 1 #"b"
0 0 22 3 2 #") "
0 0 22 29 1 #"\n"
0 0 22 3 9 #"        ("
0 0 14 3 6 #"lookup"
0 0 22 3 1 #" "
0 0 14 3 4 #"name"
0 0 22 3 1 #" "
0 0 14 3 1 #"e"
0 0 22 3 5 #")))) "
0 0 22 29 1 #"\n"
0 0 22 3 1 #"("
0 0 15 3 6 #"define"
0 0 22 3 2 #" ("
0 0 14 3 6 #"lookup"
0 0 22 3 2 #" ["
0 0 14 3 1 #"n"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 6 #"symbol"
0 0 22 3 3 #"] ["
0 0 14 3 1 #"e"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 3 #"Env"
0 0 22 3 3 #"]) "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"Value"
0 0 22 3 1 #" "
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ("
0 0 14 3 1 #"e"
0 0 22 3 1 #" "
0 0 14 3 1 #"n"
0 0 22 3 3 #")) "
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 22 3 1 #"("
0 0 15 3 6 #"define"
0 0 22 3 2 #" ("
0 0 14 3 4 #"num+"
0 0 22 3 2 #" ["
0 0 14 3 1 #"l"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"Value"
0 0 22 3 3 #"] ["
0 0 14 3 1 #"r"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"Value"
0 0 22 3 2 #"])"
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"Value"
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ("
0 0 14 3 2 #"if"
0 0 22 3 2 #" ("
0 0 14 3 3 #"and"
0 0 22 3 2 #" ("
0 0 14 3 5 #"numV?"
0 0 22 3 1 #" "
0 0 14 3 1 #"l"
0 0 22 3 3 #") ("
0 0 14 3 5 #"numV?"
0 0 22 3 1 #" "
0 0 14 3 1 #"r"
0 0 22 3 2 #"))"
0 0 22 29 1 #"\n"
0 0 22 3 7 #"      ("
0 0 14 3 4 #"numV"
0 0 22 3 2 #" ("
0 0 14 3 1 #"+"
0 0 22 3 2 #" ("
0 0 14 3 6 #"numV-n"
0 0 22 3 1 #" "
0 0 14 3 1 #"l"
0 0 22 3 3 #") ("
0 0 14 3 6 #"numV-n"
0 0 22 3 1 #" "
0 0 14 3 1 #"r"
0 0 22 3 3 #")))"
0 0 22 29 1 #"\n"
0 0 22 3 7 #"      ("
0 0 14 3 5 #"error"
0 0 22 3 1 #" "
0 0 20 3 1 #"'"
0 0 14 3 4 #"num+"
0 0 22 3 1 #" "
0 0 19 3 27 #"\"l and/or r are not numV's\""
0 0 22 3 3 #")))"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 22 3 1 #"("
0 0 15 3 6 #"define"
0 0 22 3 2 #" ("
0 0 14 3 4 #"num*"
0 0 22 3 2 #" ["
0 0 14 3 1 #"l"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"Value"
0 0 22 3 3 #"] ["
0 0 14 3 1 #"r"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"Value"
0 0 22 3 2 #"])"
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"Value"
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ("
0 0 14 3 2 #"if"
0 0 22 3 2 #" ("
0 0 14 3 3 #"and"
0 0 22 3 2 #" ("
0 0 14 3 5 #"numV?"
0 0 22 3 1 #" "
0 0 14 3 1 #"l"
0 0 22 3 3 #") ("
0 0 14 3 5 #"numV?"
0 0 22 3 1 #" "
0 0 14 3 1 #"r"
0 0 22 3 2 #"))"
0 0 22 29 1 #"\n"
0 0 22 3 7 #"      ("
0 0 14 3 4 #"numV"
0 0 22 3 2 #" ("
0 0 14 3 1 #"*"
0 0 22 3 2 #" ("
0 0 14 3 6 #"numV-n"
0 0 22 3 1 #" "
0 0 14 3 1 #"l"
0 0 22 3 3 #") ("
0 0 14 3 6 #"numV-n"
0 0 22 3 1 #" "
0 0 14 3 1 #"r"
0 0 22 3 3 #")))"
0 0 22 29 1 #"\n"
0 0 22 3 7 #"      ("
0 0 14 3 5 #"error"
0 0 22 3 1 #" "
0 0 20 3 1 #"'"
0 0 14 3 4 #"num*"
0 0 22 3 1 #" "
0 0 19 3 27 #"\"l and/or r are not numV's\""
0 0 22 3 3 #")))"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 22 3 1 #"("
0 0 15 3 6 #"define"
0 0 22 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 22 3 2 #" ["
0 0 14 3 4 #"expr"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"ExprC"
0 0 22 3 3 #"] ["
0 0 14 3 3 #"env"
0 0 22 3 1 #" "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 3 #"Env"
0 0 22 3 3 #"]) "
0 0 14 3 1 #":"
0 0 22 3 1 #" "
0 0 14 3 5 #"Value"
0 0 22 3 1 #" "
0 0 22 29 1 #"\n"
0 0 22 3 3 #"  ("
0 0 15 3 9 #"type-case"
0 0 22 3 1 #" "
0 0 14 3 5 #"ExprC"
0 0 22 3 1 #" "
0 0 14 3 4 #"expr"
0 0 22 3 1 #" "
0 0 22 29 1 #"\n"
0 0 22 3 5 #"    ["
0 0 14 3 4 #"numC"
0 0 22 3 2 #" ("
0 0 14 3 1 #"n"
0 0 22 3 3 #") ("
0 0 14 3 4 #"numV"
0 0 22 3 1 #" "
0 0 14 3 1 #"n"
0 0 22 3 3 #")] "
0 0 22 29 1 #"\n"
0 0 22 3 5 #"    ["
0 0 14 3 3 #"idC"
0 0 22 3 2 #" ("
0 0 14 3 1 #"n"
0 0 22 3 3 #") ("
0 0 14 3 6 #"lookup"
0 0 22 3 1 #" "
0 0 14 3 1 #"n"
0 0 22 3 1 #" "
0 0 14 3 3 #"env"
0 0 22 3 3 #")] "
0 0 22 29 1 #"\n"
0 0 22 3 5 #"    ["
0 0 14 3 4 #"appC"
0 0 22 3 2 #" ("
0 0 14 3 1 #"f"
0 0 22 3 1 #" "
0 0 14 3 1 #"a"
0 0 22 3 3 #") ("
0 0 15 3 5 #"local"
0 0 22 3 3 #" (["
0 0 15 3 6 #"define"
0 0 22 3 1 #" "
0 0 14 3 7 #"f-value"
0 0 22 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 22 3 1 #" "
0 0 14 3 1 #"f"
0 0 22 3 1 #" "
0 0 14 3 3 #"env"
0 0 22 3 3 #")] "
0 0 22 29 1 #"\n"
0 0 22 3 25 #"                        ["
0 0 15 3 6 #"define"
0 0 22 3 1 #" "
0 0 14 3 7 #"a-value"
0 0 22 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 22 3 1 #" "
0 0 14 3 1 #"a"
0 0 22 3 1 #" "
0 0 14 3 3 #"env"
0 0 22 3 4 #")]) "
0 0 22 29 1 #"\n"
0 0 22 3 22 #"                    (("
0 0 14 3 7 #"closV-f"
0 0 22 3 1 #" "
0 0 14 3 7 #"f-value"
0 0 22 3 2 #") "
0 0 14 3 7 #"a-value"
0 0 22 3 4 #"))] "
0 0 17 3 45 #"; ??? why are we invoking the lambda twice?!!"
0 0 22 29 1 #"\n"
0 0 22 3 5 #"    ["
0 0 14 3 5 #"plusC"
0 0 22 3 2 #" ("
0 0 14 3 1 #"l"
0 0 22 3 1 #" "
0 0 14 3 1 #"r"
0 0 22 3 3 #") ("
0 0 14 3 4 #"num+"
0 0 22 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 22 3 1 #" "
0 0 14 3 1 #"l"
0 0 22 3 1 #" "
0 0 14 3 3 #"env"
0 0 22 3 3 #") ("
0 0 14 3 6 #"interp"
0 0 22 3 1 #" "
0 0 14 3 1 #"r"
0 0 22 3 1 #" "
0 0 14 3 3 #"env"
0 0 22 3 4 #"))] "
0 0 22 29 1 #"\n"
0 0 22 3 5 #"    ["
0 0 14 3 5 #"multC"
0 0 22 3 2 #" ("
0 0 14 3 1 #"l"
0 0 22 3 1 #" "
0 0 14 3 1 #"r"
0 0 22 3 3 #") ("
0 0 14 3 4 #"num*"
0 0 22 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 22 3 1 #" "
0 0 14 3 1 #"l"
0 0 22 3 1 #" "
0 0 14 3 3 #"env"
0 0 22 3 3 #") ("
0 0 14 3 6 #"interp"
0 0 22 3 1 #" "
0 0 14 3 1 #"r"
0 0 22 3 1 #" "
0 0 14 3 3 #"env"
0 0 22 3 4 #"))] "
0 0 22 29 1 #"\n"
0 0 22 3 5 #"    ["
0 0 14 3 4 #"lamC"
0 0 22 3 2 #" ("
0 0 14 3 1 #"a"
0 0 22 3 1 #" "
0 0 14 3 1 #"b"
0 0 22 3 3 #") ("
0 0 14 3 5 #"closV"
0 0 22 3 2 #" ("
0 0 15 3 6 #"lambda"
0 0 22 3 2 #" ("
0 0 14 3 7 #"arg-val"
0 0 22 3 2 #") "
0 0 22 29 1 #"\n"
0 0 22 3 28 #"                           ("
0 0 14 3 6 #"interp"
0 0 22 3 1 #" "
0 0 14 3 1 #"b"
0 0 22 3 1 #" "
0 0 22 29 1 #"\n"
0 0 22 3 34 #"                                 ("
0 0 14 3 10 #"extend-env"
0 0 22 3 2 #" ("
0 0 14 3 4 #"bind"
0 0 22 3 1 #" "
0 0 14 3 1 #"a"
0 0 22 3 1 #" "
0 0 14 3 7 #"arg-val"
0 0 22 3 2 #") "
0 0 22 29 1 #"\n"
0 0 22 3 45 #"                                             "
0 0 14 3 3 #"env"
0 0 22 3 8 #"))))])) "
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 22 3 1 #"("
0 0 14 3 4 #"test"
0 0 22 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 22 3 2 #" ("
0 0 14 3 5 #"plusC"
0 0 22 3 2 #" ("
0 0 14 3 4 #"numC"
0 0 22 3 1 #" "
0 0 20 3 2 #"10"
0 0 22 3 3 #") ("
0 0 14 3 4 #"appC"
0 0 22 3 2 #" ("
0 0 14 3 4 #"lamC"
0 0 22 3 1 #" "
0 0 20 3 1 #"'"
0 0 14 3 1 #"_"
0 0 22 3 2 #" ("
0 0 14 3 4 #"numC"
0 0 22 3 1 #" "
0 0 20 3 1 #"5"
0 0 22 3 4 #")) ("
0 0 14 3 4 #"numC"
0 0 22 3 1 #" "
0 0 20 3 2 #"10"
0 0 22 3 4 #"))) "
0 0 22 29 1 #"\n"
0 0 22 3 14 #"              "
0 0 14 3 9 #"empty-env"
0 0 22 3 2 #") "
0 0 22 29 1 #"\n"
0 0 22 3 7 #"      ("
0 0 14 3 4 #"numV"
0 0 22 3 1 #" "
0 0 20 3 2 #"15"
0 0 22 3 3 #")) "
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 17 3 37 #"; TODO: look into why this is failing"
0 0 22 29 1 #"\n"
0 0 22 3 1 #"("
0 0 14 3 8 #"test/exn"
0 0 22 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 22 3 2 #" ("
0 0 14 3 4 #"appC"
0 0 22 3 2 #" ("
0 0 14 3 4 #"lamC"
0 0 22 3 1 #" "
0 0 20 3 1 #"'"
0 0 14 3 1 #"x"
0 0 22 3 2 #" ("
0 0 14 3 4 #"appC"
0 0 22 3 2 #" ("
0 0 14 3 4 #"lamC"
0 0 22 3 1 #" "
0 0 20 3 1 #"'"
0 0 14 3 1 #"y"
0 0 22 3 2 #" ("
0 0 14 3 5 #"plusC"
0 0 22 3 2 #" ("
0 0 14 3 3 #"idC"
0 0 22 3 1 #" "
0 0 20 3 1 #"'"
0 0 14 3 1 #"x"
0 0 22 3 3 #") ("
0 0 14 3 3 #"idC"
0 0 22 3 1 #" "
0 0 20 3 1 #"'"
0 0 14 3 1 #"y"
0 0 22 3 4 #"))) "
0 0 22 29 1 #"\n"
0 0 22 3 43 #"                                          ("
0 0 14 3 4 #"numC"
0 0 22 3 1 #" "
0 0 20 3 1 #"4"
0 0 22 3 4 #"))) "
0 0 22 29 1 #"\n"
0 0 22 3 25 #"                        ("
0 0 14 3 4 #"numC"
0 0 22 3 1 #" "
0 0 20 3 1 #"3"
0 0 22 3 3 #")) "
0 0 22 29 1 #"\n"
0 0 22 3 18 #"                  "
0 0 14 3 9 #"empty-env"
0 0 22 3 2 #") "
0 0 22 29 1 #"\n"
0 0 22 3 10 #"          "
0 0 19 3 30 #"\"lookup: symbol not found: 'x\""
0 0 22 3 2 #") "
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 17 3 24 #";; 12.3 Changing Meaning"
0 0 22 29 1 #"\n"
0 0 17 3 58
#"; TODO: Convert the above interpreter to use dynamic scope"
0 0 22 29 1 #"\n"
0 0 17 3 427
(
 #"; The moral is that this is a good property to exploit only we want "
 #"to \342\200\234pass through\342\200\235 the"
 #" base language\342\200\231s meaning\342\200\224-and then it is espec"
 #"ially wise because it ensures that we don\342\200\231t accidentally "
 #"change its meaning. If, however, we want to exploit a significant pa"
 #"rt of the base language and only augment its meaning, perhaps other "
 #"implementation strategies [REF] will work just as well instead of wr"
 #"iting an interpreter."
) 0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 17 3 14 #";; 12.2 Errors"
0 0 22 29 1 #"\n"
0 0 17 3 108
(
 #"; we have to take great care to permit only the intended surface lan"
 #"guage to be mapped to the host language."
) 0 0 22 29 1 #"\n"
0 0 17 3 226
(
 #"; consider the different mutation operations. In our language, attem"
 #"pting to mutate an unbound variable produces an error. In some langu"
 #"ages, doing so results in the variable being defined. Failing to pin"
 #" down our intended sem"
) 0 0 17 3 324
(
 #"antics is a common language designer error, saying instead, \342\200"
 #"\234It is whatever the implementation does\342\200\235. This attitud"
 #"e (a) is lazy and sloppy, (b) may yield unexpected and negative cons"
 #"equences, and (c) makes it hard for you to move your language from o"
 #"ne implementation platform to another. Don\342\200\231t ever make th"
 #"is mistake!"
) 0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";;; 12.1 Changing Representations"
0 0 22 29 1 #"\n"
0 0 17 3 17 #";#lang plai-typed"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";(define-type ExprC"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [numC (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";  [idC (s : symbol)]"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";  [appC (f : ExprC) (a : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";  [plusC (l : ExprC) (r : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";  [multC (l : ExprC) (r : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";  [lamC (a : symbol) (b : ExprC)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";(define-type Value"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [numV (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 54 #";  #;[closV (arg : symbol) (body : ExprC) (env : Env)]"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";  [closV (f : (Value -> Value))])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";(define-type Binding"
0 0 22 29 1 #"\n"
0 0 17 3 40 #";  [bind (name : symbol) (val : Value)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 41 #";(define-type-alias Env (listof Binding))"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";(define empty-env empty)"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";(define extend-env cons)"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";(define (lookup [s : symbol] [env : Env]) : Value"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";  (if (empty? env)"
0 0 22 29 1 #"\n"
0 0 17 3 73
(
 #";      (error 'lookup (string-append \"symbol not found: \" (to-stri"
 #"ng s)))"
) 0 0 22 29 1 #"\n"
0 0 17 3 45 #";      (if (equal? s (bind-name (first env)))"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";          (bind-val (first env))"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";          (lookup s (rest env)))))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 46 #";(define (num+ [l : Value] [r : Value]): Value"
0 0 22 29 1 #"\n"
0 0 17 3 32 #";  (if (and (numV? l) (numV? r))"
0 0 22 29 1 #"\n"
0 0 17 3 39 #";      (numV (+ (numV-n l) (numV-n r)))"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";      (error 'num+ \"l and/or r are not numV's\")))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 46 #";(define (num* [l : Value] [r : Value]): Value"
0 0 22 29 1 #"\n"
0 0 17 3 32 #";  (if (and (numV? l) (numV? r))"
0 0 22 29 1 #"\n"
0 0 17 3 39 #";      (numV (* (numV-n l) (numV-n r)))"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";      (error 'num* \"l and/or r are not numV's\")))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 53 #";(define (interp [expr : ExprC] [env : Env]) : Value "
0 0 22 29 1 #"\n"
0 0 17 3 25 #";  (type-case ExprC expr "
0 0 22 29 1 #"\n"
0 0 17 3 25 #";    [numC (n) (numV n)] "
0 0 22 29 1 #"\n"
0 0 17 3 30 #";    [idC (n) (lookup n env)] "
0 0 22 29 1 #"\n"
0 0 17 3 57 #";    [appC (f a) (local ([define f-value (interp f env)] "
0 0 22 29 1 #"\n"
0 0 17 3 58
#";                        [define a-value (interp a env)]) "
0 0 22 29 1 #"\n"
0 0 17 3 96
(
 #";                    ((closV-f f-value) a-value))] ; ??? why are we "
 #"invoking the lambda twice?!!"
) 0 0 22 29 1 #"\n"
0 0 17 3 56 #";    [plusC (l r) (num+ (interp l env) (interp r env))] "
0 0 22 29 1 #"\n"
0 0 17 3 56 #";    [multC (l r) (num* (interp l env) (interp r env))] "
0 0 22 29 1 #"\n"
0 0 17 3 42 #";    [lamC (a b) (closV (lambda (arg-val) "
0 0 22 29 1 #"\n"
0 0 17 3 38 #";                           (interp b "
0 0 22 29 1 #"\n"
0 0 17 3 63
#";                                 (extend-env (bind a arg-val) "
0 0 22 29 1 #"\n"
0 0 17 3 57 #";                                             env))))])) "
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 69
(
 #";(test (interp (plusC (numC 10) (appC (lamC '_ (numC 5)) (numC 10)))"
 #" "
) 0 0 22 29 1 #"\n"
0 0 17 3 26 #";              empty-env) "
0 0 22 29 1 #"\n"
0 0 17 3 18 #";      (numV 15)) "
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 76
(
 #";(test/exn (interp (appC (lamC 'x (appC (lamC 'y (plusC (idC 'x) (id"
 #"C 'y))) "
) 0 0 22 29 1 #"\n"
0 0 17 3 54 #";                                          (numC 4))) "
0 0 22 29 1 #"\n"
0 0 17 3 35 #";                        (numC 3)) "
0 0 22 29 1 #"\n"
0 0 17 3 30 #";                  empty-env) "
0 0 22 29 1 #"\n"
0 0 17 3 43 #";          \"lookup: symbol not found: 'x\") "
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 14 #";;;; Chapter 9"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 174
(
 #";;; Do Now: You\342\200\231ve already seen what goes wrong when we t"
 #"ry to use just let to define a recursive function. Try harder. Hint:"
 #" Substitute more. And then some more. And more!"
) 0 0 22 29 1 #"\n"
0 0 17 3 97
(
 #";;; Ans: can the above be implemented using Y Combintor: http://mvan"
 #"ier.livejournal.com/2897.html"
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 29 #";;; 9.3 Premature Observation"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 12 #";;#lang plai"
0 0 22 29 1 #"\n"
0 0 17 3 29 #";;(let ([fact (box 'dummy)]) "
0 0 22 29 1 #"\n"
0 0 17 3 11 #";;  (begin "
0 0 22 29 1 #"\n"
0 0 17 3 21 #";;    (set-box! fact "
0 0 22 29 1 #"\n"
0 0 17 3 28 #";;              (lambda (n) "
0 0 22 29 1 #"\n"
0 0 17 3 32 #";;                (if (zero? n) "
0 0 22 29 1 #"\n"
0 0 17 3 24 #";;                    1 "
0 0 22 29 1 #"\n"
0 0 17 3 54 #";;                    (* n ((unbox fact) (- n 1)))))) "
0 0 22 29 1 #"\n"
0 0 17 3 26 #";;    ((unbox fact) 10))) "
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";; gives us a pattern of "
0 0 22 29 1 #"\n"
0 0 17 3 24 #";; (rec name value body)"
0 0 22 29 1 #"\n"
0 0 17 3 18 #";; e.g. (rec fact "
0 0 22 29 1 #"\n"
0 0 17 3 56 #";;     (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))) "
0 0 22 29 1 #"\n"
0 0 17 3 18 #";;     (fact 10)) "
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 79
(
 #";; this will leak the initial (placeholder) value for the public's c"
 #"onsumption:"
) 0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 17 #";#lang plai-typed"
0 0 22 29 1 #"\n"
0 0 17 3 17 #";(letrec ([x x]) "
0 0 22 29 1 #"\n"
0 0 17 3 6 #";  x) "
0 0 22 29 1 #"\n"
0 0 17 3 11 #";; or this:"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";(local ([define x x])"
0 0 22 29 1 #"\n"
0 0 17 3 5 #";  x)"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 27 #";;; 9.2 Recursive Functions"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 12 #";;; Exercise"
0 0 22 29 1 #"\n"
0 0 17 3 130
(
 #";;; Run the equivalent program through your interpreter for boxes an"
 #"d make sure it produces a cyclic value. How do you check this?"
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 176
(
 #";; To implement recursive functions: first create a placeholder, the"
 #"n refer to the placeholder where we want the cyclic reference, and f"
 #"inally mutate the placeholder before use"
) 0 0 22 29 1 #"\n"
0 0 17 3 327
(
 #";; To implement recursive data: first name an vacant placeholder; th"
 #"en mutate the placeholder so its"
 #" content is itself; to obtain \342\200\234itself\342\200\235, use th"
 #"e name previously bound. Of cour"
 #"se, we need not be limited to \342\200\234self-cycles\342\200\235: w"
 #"e can also have mutually-cyclic data (where no one element is cyclic"
 #" but their combination is)."
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";(define-type ExprC"
0 0 22 29 1 #"\n"
0 0 17 3 23 #";  [numC (n : number)] "
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [idC (s : symbol)] "
0 0 22 29 1 #"\n"
0 0 17 3 38 #";  [appC (fun : ExprC) (arg : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 35 #";  [plusC (l : ExprC) (r : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 35 #";  [multC (l : ExprC) (r : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 40 #";  [lamC (arg : symbol) (body : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 24 #";  [boxC (arg : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 26 #";  [unboxC (arg : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 37 #";  [setboxC (b : ExprC) (v : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 35 #";  [seqC (b1 : ExprC) (b2 : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 47 #";  [if0C (i : ExprC) (t : ExprC) (e : ExprC)]) "
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";(define-type-alias Location number)"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";(define-type Binding"
0 0 22 29 1 #"\n"
0 0 17 3 43 #";  [bind (name : symbol) (val : Location)])"
0 0 22 29 1 #"\n"
0 0 17 3 41 #";(define-type-alias Env (listof Binding))"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";(define empty-env empty)"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";(define extend-env cons)"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";(define-type Storage"
0 0 22 29 1 #"\n"
0 0 17 3 46 #";  [cell (location : Location) (val : Value)])"
0 0 22 29 1 #"\n"
0 0 17 3 43 #";(define-type-alias Store (listof Storage))"
0 0 22 29 1 #"\n"
0 0 17 3 27 #";(define empty-store empty)"
0 0 22 29 1 #"\n"
0 0 17 3 29 #";(define override-store cons)"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";(define-type Value"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [numV (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 52 #";  [closV (arg : symbol) (body : ExprC) (env : Env)]"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";  [boxV (l : Location)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";(define-type Result"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";  [v*s (v : Value) (s : Store)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 16 #";(define new-loc"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";  (let ([n (box 0)])"
0 0 22 29 1 #"\n"
0 0 17 3 11 #";    (\316\273 ()"
0 0 22 29 1 #"\n"
0 0 17 3 13 #";      (begin"
0 0 22 29 1 #"\n"
0 0 17 3 38 #";        (set-box! n (add1 (unbox n)))"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";        (unbox n)))))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 53 #";(define (lookup [s : symbol] [env : Env]) : Location"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";  (if (empty? env)"
0 0 22 29 1 #"\n"
0 0 17 3 73
(
 #";      (error 'lookup (string-append \"symbol not found: \" (to-stri"
 #"ng s)))"
) 0 0 22 29 1 #"\n"
0 0 17 3 47 #";      (if (symbol=? s (bind-name (first env)))"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";          (bind-val (first env))"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";          (lookup s (rest env)))))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 55 #";(define (fetch [loc : Location] [sto : Store]) : Value"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";  (if (empty? sto)"
0 0 22 29 1 #"\n"
0 0 17 3 71
(
 #";      (error 'fetch (string-append \"loc not found: \" (to-string l"
 #"oc)))"
) 0 0 22 29 1 #"\n"
0 0 17 3 46 #";      (if (= loc (cell-location (first sto)))"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";          (cell-val (first sto))"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";          (fetch loc (rest sto)))))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 47 #";(define (num+ [l : Value] [r : Value]) : Value"
0 0 22 29 1 #"\n"
0 0 17 3 32 #";  (if (and (numV? l) (numV? r))"
0 0 22 29 1 #"\n"
0 0 17 3 39 #";      (numV (+ (numV-n l) (numV-n r)))"
0 0 22 29 1 #"\n"
0 0 17 3 58
#";      (error 'num+ \"num+ incorrect lhs and rhs type!!\")))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 47 #";(define (num* [l : Value] [r : Value]) : Value"
0 0 22 29 1 #"\n"
0 0 17 3 32 #";  (if (and (numV? l) (numV? r))"
0 0 22 29 1 #"\n"
0 0 17 3 39 #";      (numV (* (numV-n l) (numV-n r)))"
0 0 22 29 1 #"\n"
0 0 17 3 58
#";      (error 'num* \"num* incorrect lhs and rhs type!!\")))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 67
#";(define (interp [expr : ExprC] [env : Env] [sto : Store]) : Result"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";  (type-case ExprC expr "
0 0 22 29 1 #"\n"
0 0 17 3 20 #";    [numC (n) (v*s "
0 0 22 29 1 #"\n"
0 0 17 3 25 #";               (numV n) "
0 0 22 29 1 #"\n"
0 0 17 3 22 #";               sto)] "
0 0 22 29 1 #"\n"
0 0 17 3 5 #";    "
0 0 22 29 1 #"\n"
0 0 17 3 19 #";    [idC (n) (v*s "
0 0 22 29 1 #"\n"
0 0 17 3 22 #";              (fetch "
0 0 22 29 1 #"\n"
0 0 17 3 31 #";               (lookup n env) "
0 0 22 29 1 #"\n"
0 0 17 3 21 #";               sto) "
0 0 22 29 1 #"\n"
0 0 17 3 21 #";              sto)] "
0 0 22 29 1 #"\n"
0 0 17 3 5 #";    "
0 0 22 29 1 #"\n"
0 0 17 3 53 #";    [appC (f a) (type-case Result (interp f env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";                  [v*s (v-f s-f)"
0 0 22 29 1 #"\n"
0 0 17 3 60
#";                       (type-case Result (interp a env s-f)"
0 0 22 29 1 #"\n"
0 0 17 3 40 #";                         [v*s (v-a s-a)"
0 0 22 29 1 #"\n"
0 0 17 3 56 #";                              (let ([where (new-loc)]) "
0 0 22 29 1 #"\n"
0 0 17 3 58
#";                                (interp (closV-body v-f) "
0 0 22 29 1 #"\n"
0 0 17 3 75
(
 #";                                        (extend-env (bind (closV-ar"
 #"g v-f) "
) 0 0 22 29 1 #"\n"
0 0 17 3 66
#";                                                          where) "
0 0 22 29 1 #"\n"
0 0 17 3 70
(
 #";                                                    (closV-env v-f)"
 #") "
) 0 0 22 29 1 #"\n"
0 0 17 3 85
(
 #";                                        (override-store (cell where"
 #" v-a) s-a)))])])]"
) 0 0 22 29 1 #"\n"
0 0 17 3 5 #";    "
0 0 22 29 1 #"\n"
0 0 17 3 54 #";    [plusC (l r) (type-case Result (interp l env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";                   [v*s (v-l s-l)"
0 0 22 29 1 #"\n"
0 0 17 3 61
#";                        (type-case Result (interp r env s-l)"
0 0 22 29 1 #"\n"
0 0 17 3 41 #";                          [v*s (v-r s-r)"
0 0 22 29 1 #"\n"
0 0 17 3 62
#";                               (v*s (num+ v-l v-r) s-r)])])] "
0 0 22 29 1 #"\n"
0 0 17 3 5 #";    "
0 0 22 29 1 #"\n"
0 0 17 3 54 #";    [multC (l r) (type-case Result (interp l env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";                   [v*s (v-l s-l)"
0 0 22 29 1 #"\n"
0 0 17 3 61
#";                        (type-case Result (interp r env s-l)"
0 0 22 29 1 #"\n"
0 0 17 3 42 #";                          [v*s (v-r s-r) "
0 0 22 29 1 #"\n"
0 0 17 3 62
#";                               (v*s (num* v-l v-r) s-r)])])] "
0 0 22 29 1 #"\n"
0 0 17 3 5 #";    "
0 0 22 29 1 #"\n"
0 0 17 3 22 #";    [lamC (a b) (v*s "
0 0 22 29 1 #"\n"
0 0 17 3 34 #";                 (closV a b env) "
0 0 22 29 1 #"\n"
0 0 17 3 23 #";                 sto)]"
0 0 22 29 1 #"\n"
0 0 17 3 5 #";    "
0 0 22 29 1 #"\n"
0 0 17 3 52 #";    [boxC (a) (type-case Result (interp a env sto) "
0 0 22 29 1 #"\n"
0 0 17 3 32 #";                [v*s (v-a s-a) "
0 0 22 29 1 #"\n"
0 0 17 3 47 #";                     (let ([where (new-loc)]) "
0 0 22 29 1 #"\n"
0 0 17 3 42 #";                       (v*s (boxV where) "
0 0 22 29 1 #"\n"
0 0 17 3 62
#";                            (override-store (cell where v-a) "
0 0 22 29 1 #"\n"
0 0 17 3 55 #";                                            s-a)))])] "
0 0 22 29 1 #"\n"
0 0 17 3 5 #";    "
0 0 22 29 1 #"\n"
0 0 17 3 54 #";    [unboxC (a) (type-case Result (interp a env sto) "
0 0 22 29 1 #"\n"
0 0 17 3 34 #";                  [v*s (v-a s-a) "
0 0 22 29 1 #"\n"
0 0 17 3 62
#";                       (v*s (fetch (boxV-l v-a) s-a) s-a)])] "
0 0 22 29 1 #"\n"
0 0 17 3 5 #";    "
0 0 22 29 1 #"\n"
0 0 17 3 57 #";    [setboxC (b v) (type-case Result (interp b env sto) "
0 0 22 29 1 #"\n"
0 0 17 3 37 #";                     [v*s (v-b s-b) "
0 0 22 29 1 #"\n"
0 0 17 3 64
#";                          (type-case Result (interp v env s-b) "
0 0 22 29 1 #"\n"
0 0 17 3 44 #";                            [v*s (v-v s-v) "
0 0 22 29 1 #"\n"
0 0 17 3 43 #";                                 (v*s v-v "
0 0 22 29 1 #"\n"
0 0 17 3 74
(
 #";                                      (override-store (cell (boxV-l"
 #" v-b) "
) 0 0 22 29 1 #"\n"
0 0 17 3 66
#";                                                            v-v) "
0 0 22 29 1 #"\n"
0 0 17 3 66
#";                                                      s-v))])])] "
0 0 22 29 1 #"\n"
0 0 17 3 5 #";    "
0 0 22 29 1 #"\n"
0 0 17 3 56 #";    [seqC (b1 b2) (type-case Result (interp b1 env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 37 #";                    [v*s (v-b1 s-b1)"
0 0 22 29 1 #"\n"
0 0 17 3 49 #";                         (interp b2 env s-b1)])]"
0 0 22 29 1 #"\n"
0 0 17 3 5 #";    "
0 0 22 29 1 #"\n"
0 0 17 3 55 #";    [if0C (i t e) (type-case Result (interp i env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";                    [v*s (v-i s-i)"
0 0 22 29 1 #"\n"
0 0 17 3 48 #";                         (if (= (numV-n v-i) 0)"
0 0 22 29 1 #"\n"
0 0 17 3 48 #";                             (interp t env s-i)"
0 0 22 29 1 #"\n"
0 0 17 3 54 #";                             (interp e env s-i))])]))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 11 #";#;((\316\273 (x)"
0 0 22 29 1 #"\n"
0 0 17 3 10 #";   (begin"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";     (set-box! x x)"
0 0 22 29 1 #"\n"
0 0 17 3 9 #";     x))"
0 0 22 29 1 #"\n"
0 0 17 3 15 #"; (box 'dummy))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 68
#";; will fail with error: fact: unbound identifier in module in: fact"
0 0 22 29 1 #"\n"
0 0 17 3 27 #";#;(let ([fact (lambda (n) "
0 0 22 29 1 #"\n"
0 0 17 3 21 #";              (if 1 "
0 0 22 29 1 #"\n"
0 0 17 3 21 #";                  n "
0 0 22 29 1 #"\n"
0 0 17 3 44 #";                  (* n (fact (- n 1)))))]) "
0 0 22 29 1 #"\n"
0 0 17 3 14 #";  (fact 10)) "
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 88
(
 #";; above desugared with same error as above: fact: unbound identifie"
 #"r in module in: fact"
) 0 0 22 29 1 #"\n"
0 0 17 3 14 #";#;((\316\273 (fact)"
0 0 22 29 1 #"\n"
0 0 17 3 16 #";   (lambda (n) "
0 0 22 29 1 #"\n"
0 0 17 3 21 #";              (if 1 "
0 0 22 29 1 #"\n"
0 0 17 3 21 #";                  n "
0 0 22 29 1 #"\n"
0 0 17 3 42 #";                  (* n (fact (- n 1))))))"
0 0 22 29 1 #"\n"
0 0 17 3 12 #"; (fact 10))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 60
#";(define test-if0-true (if0C (numC 3) (numC 10) (numC 299)))"
0 0 22 29 1 #"\n"
0 0 17 3 61
#";(define test-if0-false (if0C (numC 0) (numC 19) (numC 299)))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 81
(
 #";(test (interp test-if0-true empty-env empty-store) (v*s (numV 299) "
 #"empty-store))"
) 0 0 22 29 1 #"\n"
0 0 17 3 80
(
 #";(test (interp test-if0-true empty-env empty-store) (v*s (numV 19) e"
 #"mpty-store))"
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 105
(
 #";(define test-cyclic-data (appC (lamC 'x (seqC (setboxC (idC 'x) (id"
 #"C 'x)) (idC 'x))) (boxC (numC 123))))"
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 59
#";(define t (interp test-cyclic-data empty-env empty-store))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";; todo: is this actually cyclic??"
0 0 22 29 1 #"\n"
0 0 17 3 87
(
 #";(test t (v*s (boxV 1) (list (cell 1 (boxV 1)) (cell 2 (boxV 1)) (ce"
 #"ll 1 (numV 123)))))"
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 31 #";;; compile following with plai"
0 0 22 29 1 #"\n"
0 0 17 3 12 #";;#lang plai"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 28 #";;(let ([fact (box 'dummy)])"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";;  (let ([fact-fun"
0 0 22 29 1 #"\n"
0 0 17 3 18 #";;         (\316\273 (n)"
0 0 22 29 1 #"\n"
0 0 17 3 26 #";;           (if (zero? n)"
0 0 22 29 1 #"\n"
0 0 17 3 18 #";;               1"
0 0 22 29 1 #"\n"
0 0 17 3 49 #";;               (* n ((unbox fact) (- n 1)))))])"
0 0 22 29 1 #"\n"
0 0 17 3 10 #";;  (begin"
0 0 22 29 1 #"\n"
0 0 17 3 30 #";;    (set-box! fact fact-fun)"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";;    ((unbox fact) 3))))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;; Desugaring above"
0 0 22 29 1 #"\n"
0 0 17 3 29 #";;(let ([fact (box 'dummy)]) "
0 0 22 29 1 #"\n"
0 0 17 3 11 #";;  (begin "
0 0 22 29 1 #"\n"
0 0 17 3 21 #";;    (set-box! fact "
0 0 22 29 1 #"\n"
0 0 17 3 28 #";;              (lambda (n) "
0 0 22 29 1 #"\n"
0 0 17 3 32 #";;                (if (zero? n) "
0 0 22 29 1 #"\n"
0 0 17 3 24 #";;                    1 "
0 0 22 29 1 #"\n"
0 0 17 3 54 #";;                    (* n ((unbox fact) (- n 1)))))) "
0 0 22 29 1 #"\n"
0 0 17 3 26 #";;    ((unbox fact) 10))) "
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 47 #";;; Using variables instead of boxes from above"
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;(let ([fact 'dummy]) "
0 0 22 29 1 #"\n"
0 0 17 3 13 #";;    (begin "
0 0 22 29 1 #"\n"
0 0 17 3 19 #";;      (set! fact "
0 0 22 29 1 #"\n"
0 0 17 3 26 #";;            (lambda (n) "
0 0 22 29 1 #"\n"
0 0 17 3 30 #";;              (if (zero? n) "
0 0 22 29 1 #"\n"
0 0 17 3 22 #";;                  1 "
0 0 22 29 1 #"\n"
0 0 17 3 44 #";;                  (* n (fact (- n 1)))))) "
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;      (fact 10))) "
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 13 #";; #lang plai"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 75
(
 #";;; When the following program is"
 #" Run, Racket prints this as: #0=\342\200\231#&#0#. "
) 0 0 22 29 1 #"\n"
0 0 17 3 53 #";;; This notation is in fact precisely what we want. "
0 0 22 29 1 #"\n"
0 0 17 3 47 #";;; Recall that #& is how Racket prints boxes. "
0 0 22 29 1 #"\n"
0 0 17 3 89
(
 #";;; The #0= (and similarly for other numbers) is how Racket names pi"
 #"eces of cyclic data. "
) 0 0 22 29 1 #"\n"
0 0 17 3 80
(
 #";;; Thus, Racket is saying, \342\200\234#0 is bound to a box whose c"
 #"ontent is #0#, i.e., "
) 0 0 22 29 1 #"\n"
0 0 17 3 46 #";;;  whatever is bound to #0, i.e., itself\342\200\235."
0 0 22 29 1 #"\n"
0 0 17 3 25 #";;(let ([b (box 'dummy)])"
0 0 22 29 1 #"\n"
0 0 17 3 11 #";;  (begin "
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;    (set-box! b b)"
0 0 22 29 1 #"\n"
0 0 17 3 9 #";;    b))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 18 #";;#lang plai-typed"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;(define-type ExprC"
0 0 22 29 1 #"\n"
0 0 17 3 24 #";;  [numC (n : number)] "
0 0 22 29 1 #"\n"
0 0 17 3 24 #";;  [varC (s : symbol)] "
0 0 22 29 1 #"\n"
0 0 17 3 39 #";;  [appC (fun : ExprC) (arg : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 36 #";;  [plusC (l : ExprC) (r : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 36 #";;  [multC (l : ExprC) (r : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 41 #";;  [lamC (arg : symbol) (body : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 40 #";;  [setC (var : symbol) (arg : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 36 #";;  [seqC (b1 : ExprC) (b2 : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 53 #";;  [treeC (val : 'a) (left : ExprC) (right : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 38 #";;  [listC (val : 'a) (next : ExprC)])"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 67
#";;(define my-list (listC 1 (listC 3 (listC 5 (listC 6 (numC 0))))))"
0 0 22 29 1 #"\n"
0 0 17 3 47 #";;(define node1 (treeC 'abc (numC 0) (numC 0)))"
0 0 22 29 1 #"\n"
0 0 17 3 47 #";;(define node2 (treeC 'xyz (numC 0) (numC 0)))"
0 0 22 29 1 #"\n"
0 0 17 3 41 #";;(define node3 (treeC 'def node1 node2))"
0 0 22 29 1 #"\n"
0 0 17 3 66
#";;(define my-tree (treeC 'uvw node3 (treeC '_ (numC 0) (numC 0))))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 9 #";;my-list"
0 0 22 29 1 #"\n"
0 0 17 3 9 #";;my-tree"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";;; won't work since b is undefined"
0 0 22 29 1 #"\n"
0 0 17 3 16 #";;#;(let ([b b])"
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;  b)"
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;; the above desugared"
0 0 22 29 1 #"\n"
0 0 17 3 12 #";;#;((\316\273 (b)"
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;  b)"
0 0 22 29 1 #"\n"
0 0 17 3 5 #";; b)"
0 0 22 29 1 #"\n"
0 0 17 3 11 #";;; or even"
0 0 22 29 1 #"\n"
0 0 17 3 12 #";;#;((\316\273 (x)"
0 0 22 29 1 #"\n"
0 0 17 3 7 #";;   x)"
0 0 22 29 1 #"\n"
0 0 17 3 5 #";; b)"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 189
(
 #";;;we need to first create a \342\200\234place\342\200\235 for the d"
 #"atum, then refer to that place"
 #" within itself. The use o"
 #"f \342\200\234then\342\200\235\342\200\224i.e., the "
 #"introduction of time\342\200\224should suggest a mutation operation."
) 0 0 22 29 1 #"\n"
0 0 17 3 194
(
 #";;;Note that this program will not"
 #" run in Typed PLAI as written. We\342\200\231ll return to typing suc"
 #"h programs later [REF]. For now, run it in the untyped (#lang plai) "
 #"language.;(let ([b (box 'dummy)])"
) 0 0 22 29 1 #"\n"
0 0 17 3 25 #";;(let ([b (box 'dummy)])"
0 0 22 29 1 #"\n"
0 0 17 3 11 #";;  (begin "
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;    (set-box! b b)"
0 0 22 29 1 #"\n"
0 0 17 3 9 #";;    b))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 5 #";;;;;"
0 0 22 29 1 #"\n"
0 0 17 3 15 #";;;;; Chapter 8"
0 0 22 29 1 #"\n"
0 0 17 3 5 #";;;;;"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 18 #";;#lang plai-typed"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 46 #";;;; using variables (i.e. variable mutation )"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;(define-type ExprC"
0 0 22 29 1 #"\n"
0 0 17 3 24 #";;  [numC (n : number)] "
0 0 22 29 1 #"\n"
0 0 17 3 24 #";;  [varC (s : symbol)] "
0 0 22 29 1 #"\n"
0 0 17 3 39 #";;  [appC (fun : ExprC) (arg : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 36 #";;  [plusC (l : ExprC) (r : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 36 #";;  [multC (l : ExprC) (r : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 41 #";;  [lamC (arg : symbol) (body : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 40 #";;  [setC (var : symbol) (arg : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 38 #";;  [seqC (b1 : ExprC) (b2 : ExprC)]) "
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;(define-type Value"
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;  [numV (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 54 #";;  [closV (arg : symbol) (body : ExprC) (env : Env)])"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 37 #";;(define-type-alias Location number)"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";;(define-type Binding"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";;  [bind (name : symbol) (val : Location)])"
0 0 22 29 1 #"\n"
0 0 17 3 42 #";;(define-type-alias Env (listof Binding))"
0 0 22 29 1 #"\n"
0 0 17 3 26 #";;(define empty-env empty)"
0 0 22 29 1 #"\n"
0 0 17 3 26 #";;(define extend-env cons)"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";;(define-type Storage"
0 0 22 29 1 #"\n"
0 0 17 3 47 #";;  [cell (location : Location) (val : Value)])"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";;(define-type-alias Store (listof Storage))"
0 0 22 29 1 #"\n"
0 0 17 3 28 #";;(define empty-store empty)"
0 0 22 29 1 #"\n"
0 0 17 3 30 #";;(define override-store cons)"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";;(define-type Result"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";;  [v*s (v : Value) (s : Store)])"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 17 #";;(define new-loc"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";;  (let ([n (box 0)])"
0 0 22 29 1 #"\n"
0 0 17 3 12 #";;    (\316\273 ()"
0 0 22 29 1 #"\n"
0 0 17 3 14 #";;      (begin"
0 0 22 29 1 #"\n"
0 0 17 3 39 #";;        (set-box! n (add1 (unbox n)))"
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;        (unbox n)))))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 54 #";;(define (lookup [s : symbol] [env : Env]) : Location"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;  (if (empty? env)"
0 0 22 29 1 #"\n"
0 0 17 3 74
(
 #";;      (error 'lookup (string-append \"symbol not found: \" (to-str"
 #"ing s)))"
) 0 0 22 29 1 #"\n"
0 0 17 3 48 #";;      (if (symbol=? s (bind-name (first env)))"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";;          (bind-val (first env))"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";;          (lookup s (rest env)))))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 56 #";;(define (fetch [loc : Location] [sto : Store]) : Value"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;  (if (empty? sto)"
0 0 22 29 1 #"\n"
0 0 17 3 72
(
 #";;      (error 'fetch (string-append \"loc not found: \" (to-string "
 #"loc)))"
) 0 0 22 29 1 #"\n"
0 0 17 3 47 #";;      (if (= loc (cell-location (first sto)))"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";;          (cell-val (first sto))"
0 0 22 29 1 #"\n"
0 0 17 3 37 #";;          (fetch loc (rest sto)))))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 48 #";;(define (num+ [l : Value] [r : Value]) : Value"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";;  (if (and (numV? l) (numV? r))"
0 0 22 29 1 #"\n"
0 0 17 3 40 #";;      (numV (+ (numV-n l) (numV-n r)))"
0 0 22 29 1 #"\n"
0 0 17 3 59
#";;      (error 'num+ \"num+ incorrect lhs and rhs type!!\")))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 48 #";;(define (num* [l : Value] [r : Value]) : Value"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";;  (if (and (numV? l) (numV? r))"
0 0 22 29 1 #"\n"
0 0 17 3 40 #";;      (numV (* (numV-n l) (numV-n r)))"
0 0 22 29 1 #"\n"
0 0 17 3 59
#";;      (error 'num* \"num* incorrect lhs and rhs type!!\")))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 68
#";;(define (interp [expr : ExprC] [env : Env] [sto : Store]) : Result"
0 0 22 29 1 #"\n"
0 0 17 3 26 #";;  (type-case ExprC expr "
0 0 22 29 1 #"\n"
0 0 17 3 21 #";;    [numC (n) (v*s "
0 0 22 29 1 #"\n"
0 0 17 3 26 #";;               (numV n) "
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;               sto)] "
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 21 #";;    [varC (n) (v*s "
0 0 22 29 1 #"\n"
0 0 17 3 24 #";;               (fetch "
0 0 22 29 1 #"\n"
0 0 17 3 33 #";;                (lookup n env) "
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;                sto) "
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;               sto)] "
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 54 #";;    [appC (f a) (type-case Result (interp f env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";;                  [v*s (v-f s-f)"
0 0 22 29 1 #"\n"
0 0 17 3 61
#";;                       (type-case Result (interp a env s-f)"
0 0 22 29 1 #"\n"
0 0 17 3 41 #";;                         [v*s (v-a s-a)"
0 0 22 29 1 #"\n"
0 0 17 3 57 #";;                              (let ([where (new-loc)]) "
0 0 22 29 1 #"\n"
0 0 17 3 59
#";;                                (interp (closV-body v-f) "
0 0 22 29 1 #"\n"
0 0 17 3 76
(
 #";;                                        (extend-env (bind (closV-a"
 #"rg v-f) "
) 0 0 22 29 1 #"\n"
0 0 17 3 67
#";;                                                          where) "
0 0 22 29 1 #"\n"
0 0 17 3 71
(
 #";;                                                    (closV-env v-f"
 #")) "
) 0 0 22 29 1 #"\n"
0 0 17 3 86
(
 #";;                                        (override-store (cell wher"
 #"e v-a) s-a)))])])]"
) 0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 55 #";;    [plusC (l r) (type-case Result (interp l env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";;                   [v*s (v-l s-l)"
0 0 22 29 1 #"\n"
0 0 17 3 62
#";;                        (type-case Result (interp r env s-l)"
0 0 22 29 1 #"\n"
0 0 17 3 42 #";;                          [v*s (v-r s-r)"
0 0 22 29 1 #"\n"
0 0 17 3 63
#";;                               (v*s (num+ v-l v-r) s-r)])])] "
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 55 #";;    [multC (l r) (type-case Result (interp l env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";;                   [v*s (v-l s-l)"
0 0 22 29 1 #"\n"
0 0 17 3 62
#";;                        (type-case Result (interp r env s-l)"
0 0 22 29 1 #"\n"
0 0 17 3 43 #";;                          [v*s (v-r s-r) "
0 0 22 29 1 #"\n"
0 0 17 3 63
#";;                               (v*s (num* v-l v-r) s-r)])])] "
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;    [lamC (a b) (v*s "
0 0 22 29 1 #"\n"
0 0 17 3 35 #";;                 (closV a b env) "
0 0 22 29 1 #"\n"
0 0 17 3 24 #";;                 sto)]"
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 60
#";;    [setC (var val) (type-case Result (interp val env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 42 #";;                      [v*s (v-val s-val)"
0 0 22 29 1 #"\n"
0 0 17 3 60
#";;                           (let ([where (lookup var env)])"
0 0 22 29 1 #"\n"
0 0 17 3 41 #";;                             (v*s v-val"
0 0 22 29 1 #"\n"
0 0 17 3 52 #";;                                  (override-store "
0 0 22 29 1 #"\n"
0 0 17 3 55 #";;                                   (cell where v-val)"
0 0 22 29 1 #"\n"
0 0 17 3 48 #";;                                   s-val)))])]"
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 57 #";;    [seqC (b1 b2) (type-case Result (interp b1 env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 38 #";;                    [v*s (v-b1 s-b1)"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";;                         (interp b2 env s-b1)])]"
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 8 #";;    ))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";;(test (interp (appC"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";;           (lamC "
0 0 22 29 1 #"\n"
0 0 17 3 16 #";;           'x "
0 0 22 29 1 #"\n"
0 0 17 3 53 #";;           (plusC (setC 'x (numC 10)) (numC 100))) "
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;           (numC 50))"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";;          empty-env "
0 0 22 29 1 #"\n"
0 0 17 3 24 #";;          empty-store)"
0 0 22 29 1 #"\n"
0 0 17 3 70
(
 #";;      (v*s (numV 110) (list (cell 1 (numV 10)) (cell 1 (numV 50)))"
 #"))"
) 0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 49 #";;;; using identifiers (i.e. structure mutation )"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;(define-type ExprC"
0 0 22 29 1 #"\n"
0 0 17 3 24 #";;  [numC (n : number)] "
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;  [idC (s : symbol)] "
0 0 22 29 1 #"\n"
0 0 17 3 39 #";;  [appC (fun : ExprC) (arg : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 36 #";;  [plusC (l : ExprC) (r : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 36 #";;  [multC (l : ExprC) (r : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 41 #";;  [lamC (arg : symbol) (body : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 25 #";;  [boxC (arg : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 27 #";;  [unboxC (arg : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 38 #";;  [setboxC (b : ExprC) (v : ExprC)] "
0 0 22 29 1 #"\n"
0 0 17 3 38 #";;  [seqC (b1 : ExprC) (b2 : ExprC)]) "
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 37 #";;(define-type-alias Location number)"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";;(define-type Binding"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";;  [bind (name : symbol) (val : Location)])"
0 0 22 29 1 #"\n"
0 0 17 3 42 #";;(define-type-alias Env (listof Binding))"
0 0 22 29 1 #"\n"
0 0 17 3 26 #";;(define empty-env empty)"
0 0 22 29 1 #"\n"
0 0 17 3 26 #";;(define extend-env cons)"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";;(define-type Storage"
0 0 22 29 1 #"\n"
0 0 17 3 47 #";;  [cell (location : Location) (val : Value)])"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";;(define-type-alias Store (listof Storage))"
0 0 22 29 1 #"\n"
0 0 17 3 28 #";;(define empty-store empty)"
0 0 22 29 1 #"\n"
0 0 17 3 30 #";;(define override-store cons)"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;(define-type Value"
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;  [numV (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 53 #";;  [closV (arg : symbol) (body : ExprC) (env : Env)]"
0 0 22 29 1 #"\n"
0 0 17 3 26 #";;  [boxV (l : Location)])"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";;(define-type Result"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";;  [v*s (v : Value) (s : Store)])"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 17 #";;(define new-loc"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";;  (let ([n (box 0)])"
0 0 22 29 1 #"\n"
0 0 17 3 12 #";;    (\316\273 ()"
0 0 22 29 1 #"\n"
0 0 17 3 14 #";;      (begin"
0 0 22 29 1 #"\n"
0 0 17 3 39 #";;        (set-box! n (add1 (unbox n)))"
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;        (unbox n)))))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 54 #";;(define (lookup [s : symbol] [env : Env]) : Location"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;  (if (empty? env)"
0 0 22 29 1 #"\n"
0 0 17 3 74
(
 #";;      (error 'lookup (string-append \"symbol not found: \" (to-str"
 #"ing s)))"
) 0 0 22 29 1 #"\n"
0 0 17 3 48 #";;      (if (symbol=? s (bind-name (first env)))"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";;          (bind-val (first env))"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";;          (lookup s (rest env)))))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 56 #";;(define (fetch [loc : Location] [sto : Store]) : Value"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;  (if (empty? sto)"
0 0 22 29 1 #"\n"
0 0 17 3 72
(
 #";;      (error 'fetch (string-append \"loc not found: \" (to-string "
 #"loc)))"
) 0 0 22 29 1 #"\n"
0 0 17 3 47 #";;      (if (= loc (cell-location (first sto)))"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";;          (cell-val (first sto))"
0 0 22 29 1 #"\n"
0 0 17 3 37 #";;          (fetch loc (rest sto)))))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 48 #";;(define (num+ [l : Value] [r : Value]) : Value"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";;  (if (and (numV? l) (numV? r))"
0 0 22 29 1 #"\n"
0 0 17 3 40 #";;      (numV (+ (numV-n l) (numV-n r)))"
0 0 22 29 1 #"\n"
0 0 17 3 59
#";;      (error 'num+ \"num+ incorrect lhs and rhs type!!\")))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 48 #";;(define (num* [l : Value] [r : Value]) : Value"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";;  (if (and (numV? l) (numV? r))"
0 0 22 29 1 #"\n"
0 0 17 3 40 #";;      (numV (* (numV-n l) (numV-n r)))"
0 0 22 29 1 #"\n"
0 0 17 3 59
#";;      (error 'num* \"num* incorrect lhs and rhs type!!\")))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 68
#";;(define (interp [expr : ExprC] [env : Env] [sto : Store]) : Result"
0 0 22 29 1 #"\n"
0 0 17 3 26 #";;  (type-case ExprC expr "
0 0 22 29 1 #"\n"
0 0 17 3 21 #";;    [numC (n) (v*s "
0 0 22 29 1 #"\n"
0 0 17 3 26 #";;               (numV n) "
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;               sto)] "
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 20 #";;    [idC (n) (v*s "
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;              (fetch "
0 0 22 29 1 #"\n"
0 0 17 3 32 #";;               (lookup n env) "
0 0 22 29 1 #"\n"
0 0 17 3 22 #";;               sto) "
0 0 22 29 1 #"\n"
0 0 17 3 22 #";;              sto)] "
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 54 #";;    [appC (f a) (type-case Result (interp f env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";;                  [v*s (v-f s-f)"
0 0 22 29 1 #"\n"
0 0 17 3 61
#";;                       (type-case Result (interp a env s-f)"
0 0 22 29 1 #"\n"
0 0 17 3 41 #";;                         [v*s (v-a s-a)"
0 0 22 29 1 #"\n"
0 0 17 3 57 #";;                              (let ([where (new-loc)]) "
0 0 22 29 1 #"\n"
0 0 17 3 59
#";;                                (interp (closV-body v-f) "
0 0 22 29 1 #"\n"
0 0 17 3 76
(
 #";;                                        (extend-env (bind (closV-a"
 #"rg v-f) "
) 0 0 22 29 1 #"\n"
0 0 17 3 67
#";;                                                          where) "
0 0 22 29 1 #"\n"
0 0 17 3 71
(
 #";;                                                    (closV-env v-f"
 #")) "
) 0 0 22 29 1 #"\n"
0 0 17 3 86
(
 #";;                                        (override-store (cell wher"
 #"e v-a) s-a)))])])]"
) 0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 55 #";;    [plusC (l r) (type-case Result (interp l env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";;                   [v*s (v-l s-l)"
0 0 22 29 1 #"\n"
0 0 17 3 62
#";;                        (type-case Result (interp r env s-l)"
0 0 22 29 1 #"\n"
0 0 17 3 42 #";;                          [v*s (v-r s-r)"
0 0 22 29 1 #"\n"
0 0 17 3 63
#";;                               (v*s (num+ v-l v-r) s-r)])])] "
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 55 #";;    [multC (l r) (type-case Result (interp l env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";;                   [v*s (v-l s-l)"
0 0 22 29 1 #"\n"
0 0 17 3 62
#";;                        (type-case Result (interp r env s-l)"
0 0 22 29 1 #"\n"
0 0 17 3 43 #";;                          [v*s (v-r s-r) "
0 0 22 29 1 #"\n"
0 0 17 3 63
#";;                               (v*s (num* v-l v-r) s-r)])])] "
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;    [lamC (a b) (v*s "
0 0 22 29 1 #"\n"
0 0 17 3 35 #";;                 (closV a b env) "
0 0 22 29 1 #"\n"
0 0 17 3 24 #";;                 sto)]"
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 53 #";;    [boxC (a) (type-case Result (interp a env sto) "
0 0 22 29 1 #"\n"
0 0 17 3 33 #";;                [v*s (v-a s-a) "
0 0 22 29 1 #"\n"
0 0 17 3 48 #";;                     (let ([where (new-loc)]) "
0 0 22 29 1 #"\n"
0 0 17 3 43 #";;                       (v*s (boxV where) "
0 0 22 29 1 #"\n"
0 0 17 3 63
#";;                            (override-store (cell where v-a) "
0 0 22 29 1 #"\n"
0 0 17 3 56 #";;                                            s-a)))])] "
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 55 #";;    [unboxC (a) (type-case Result (interp a env sto) "
0 0 22 29 1 #"\n"
0 0 17 3 35 #";;                  [v*s (v-a s-a) "
0 0 22 29 1 #"\n"
0 0 17 3 63
#";;                       (v*s (fetch (boxV-l v-a) s-a) s-a)])] "
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 58
#";;    [setboxC (b v) (type-case Result (interp b env sto) "
0 0 22 29 1 #"\n"
0 0 17 3 38 #";;                     [v*s (v-b s-b) "
0 0 22 29 1 #"\n"
0 0 17 3 65
#";;                          (type-case Result (interp v env s-b) "
0 0 22 29 1 #"\n"
0 0 17 3 45 #";;                            [v*s (v-v s-v) "
0 0 22 29 1 #"\n"
0 0 17 3 44 #";;                                 (v*s v-v "
0 0 22 29 1 #"\n"
0 0 17 3 75
(
 #";;                                      (override-store (cell (boxV-"
 #"l v-b) "
) 0 0 22 29 1 #"\n"
0 0 17 3 67
#";;                                                            v-v) "
0 0 22 29 1 #"\n"
0 0 17 3 67
#";;                                                      s-v))])])] "
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 57 #";;    [seqC (b1 b2) (type-case Result (interp b1 env sto)"
0 0 22 29 1 #"\n"
0 0 17 3 38 #";;                    [v*s (v-b1 s-b1)"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";;                         (interp b2 env s-b1)])]"
0 0 22 29 1 #"\n"
0 0 17 3 6 #";;    "
0 0 22 29 1 #"\n"
0 0 17 3 8 #";;    ))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 70
(
 #";;; todo: Define begin by desugaring into let (and hence into lambda"
 #")."
) 0 0 22 29 1 #"\n"
0 0 17 3 161
(
 #";;; todo: Implement the other version of store alteration, whereby w"
 #"e update an existing binding and thereby avoid multiple bindings for"
 #" a location in the store."
) 0 0 22 29 1 #"\n"
0 0 17 3 133
(
 #";;; todo: It\342\200\231s a useful exercise to try to limit the use "
 #"of store locations only to boxes. How many changes would you need to"
 #" make?"
) 0 0 22 29 1 #"\n"
0 0 17 3 179
(
 #";;; todo: Go through the interpreter; replace every reference to an "
 #"updated store with a reference to one before update; make sure your "
 #"test cases catch all the introduced errors!"
) 0 0 22 29 1 #"\n"
0 0 17 3 98
(
 #";;; todo: Augment the language with the journal features of software"
 #" transactional memory journal."
) 0 0 22 29 1 #"\n"
0 0 17 3 140
(
 #";;; todo: An alternate implementation strategy is to have the enviro"
 #"nment map names to boxed Values. We don\342\200\231t do it here beca"
 #"use it: (a) w"
) 0 0 17 3 506
(
 #"ould be cheating, (b) wouldn\342\200\231t tell us how to implement t"
 #"he same feature in a language without boxes, (c) doesn\342\200\231t "
 #"necessarily carry over to other mutation operations, and (d) most of"
 #" all, doesn\342\200\231t really give us insight into what is happeni"
 #"ng here. It is nevertheless useful to understand, not least because "
 #"you may find it a useful strategy to adopt when implementing your ow"
 #"n language. Therefore, alter the implementation to obey this strateg"
 #"y. Do you still need store-passing style? Why or why not?"
) 0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 59
#";;(define test1 (plusC (unboxC (boxC (numC 10))) (numC 9)))"
0 0 22 29 1 #"\n"
0 0 17 3 78
(
 #";;(define test2-seqC-take1 (seqC (plusC (numC 1) (numC 2)) (boxC (nu"
 #"mC 100))))"
) 0 0 22 29 1 #"\n"
0 0 17 3 78
(
 #";;(define test3-seqC-take1 (seqC (boxC (numC 100)) (plusC (numC 1) ("
 #"numC 2))))"
) 0 0 22 29 1 #"\n"
0 0 17 3 88
(
 #";;(define test4-seqC-take2 (seqC (plusC (numC 1) (numC 2)) (multC (n"
 #"umC 100) (numC 3))))"
) 0 0 22 29 1 #"\n"
0 0 17 3 88
(
 #";;(define test5-seqC-take2 (seqC (multC (numC 100) (numC 3)) (plusC "
 #"(numC 1) (numC 2))))"
) 0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 87
(
 #";;(test (interp test1 empty-env empty-store) (v*s (numV 19) (list (c"
 #"ell 1 (numV 10)))))"
) 0 0 22 29 1 #"\n"
0 0 17 3 98
(
 #";;(test (interp test2-seqC-take1 empty-env empty-store) (v*s (boxV 2"
 #") (list (cell 2 (numV 100)))))"
) 0 0 22 29 1 #"\n"
0 0 17 3 98
(
 #";;(test (interp test3-seqC-take1 empty-env empty-store) (v*s (numV 3"
 #") (list (cell 3 (numV 100)))))"
) 0 0 22 29 1 #"\n"
0 0 17 3 85
(
 #";;(test (interp test4-seqC-take2 empty-env empty-store) (v*s (numV 3"
 #"00) empty-store))"
) 0 0 22 29 1 #"\n"
0 0 17 3 83
(
 #";;(test (interp test5-seqC-take2 empty-env empty-store) (v*s (numV 3"
 #") empty-store))"
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 14 #";;;; Chapter 7"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";(define-type ExprC"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [numC (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";  [idC (s : symbol)]"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";  [appC (f : ExprC) (a : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";  [plusC (l : ExprC) (r : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";  [multC (l : ExprC) (r : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 138
(
 #";  ;[fdC (f : symbol) (a : symbol) (b : ExprC)] ;A function is inher"
 #"ently anonymous, and we should separate its definition from its nami"
 #"ng"
) 0 0 22 29 1 #"\n"
0 0 17 3 35 #";  [lamC (a : symbol) (b : ExprC)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";(define-type Value"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [numV (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 154
(
 #";  ;[funV (name : symbol) (arg : symbol) (body : ExprC)] ; We need t"
 #"o change our representation of values to record closures rather than"
 #" raw function text"
) 0 0 22 29 1 #"\n"
0 0 17 3 64
#";  [closV (arg : symbol) (body : ExprC) (env : Env)]); a closure"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";(define-type Binding"
0 0 22 29 1 #"\n"
0 0 17 3 40 #";  [bind (name : symbol) (val : Value)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 41 #";(define-type-alias Env (listof Binding))"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";(define empty-env empty)"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";(define extend-env cons)"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";(define (lookup [s : symbol] [env : Env]) : Value"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";  (if (empty? env)"
0 0 22 29 1 #"\n"
0 0 17 3 73
(
 #";      (error 'lookup (string-append \"symbol not found: \" (to-stri"
 #"ng s)))"
) 0 0 22 29 1 #"\n"
0 0 17 3 45 #";      (if (equal? s (bind-name (first env)))"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";          (bind-val (first env))"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";          (lookup s (rest env)))))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 46 #";(define (num+ [l : Value] [r : Value]): Value"
0 0 22 29 1 #"\n"
0 0 17 3 32 #";  (if (and (numV? l) (numV? r))"
0 0 22 29 1 #"\n"
0 0 17 3 39 #";      (numV (+ (numV-n l) (numV-n r)))"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";      (error 'num+ \"l and/or r are not numV's\")))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 46 #";(define (num* [l : Value] [r : Value]): Value"
0 0 22 29 1 #"\n"
0 0 17 3 32 #";  (if (and (numV? l) (numV? r))"
0 0 22 29 1 #"\n"
0 0 17 3 39 #";      (numV (* (numV-n l) (numV-n r)))"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";      (error 'num* \"l and/or r are not numV's\")))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 49 #";(define (interp [e : ExprC] [env : Env]) : Value"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";  (type-case ExprC e"
0 0 22 29 1 #"\n"
0 0 17 3 24 #";    [numC (n) (numV n)]"
0 0 22 29 1 #"\n"
0 0 17 3 29 #";    [idC (s) (lookup s env)]"
0 0 22 29 1 #"\n"
0 0 17 3 54 #";    #;[appC (f a) (local ([define fd (interp f env)])"
0 0 22 29 1 #"\n"
0 0 17 3 134
(
 #";                    (interp (funV-body fd) ;A function is inherentl"
 #"y anonymous, and we should separate its definition from its naming"
) 0 0 22 29 1 #"\n"
0 0 17 3 41 #";                            (extend-env "
0 0 22 29 1 #"\n"
0 0 17 3 36 #";                             (bind "
0 0 22 29 1 #"\n"
0 0 17 3 45 #";                              (funV-arg fd) "
0 0 22 29 1 #"\n"
0 0 17 3 47 #";                              (interp a env)) "
0 0 22 29 1 #"\n"
0 0 17 3 43 #";                             empty-env)))]"
0 0 22 29 1 #"\n"
0 0 17 3 57 #";    [appC (f a) (local ([define f-value (interp f env)])"
0 0 22 29 1 #"\n"
0 0 17 3 27 #";                  (interp "
0 0 22 29 1 #"\n"
0 0 17 3 40 #";                   (closV-body f-value)"
0 0 22 29 1 #"\n"
0 0 17 3 32 #";                   (extend-env "
0 0 22 29 1 #"\n"
0 0 17 3 27 #";                    (bind "
0 0 22 29 1 #"\n"
0 0 17 3 42 #";                     (closV-arg f-value) "
0 0 22 29 1 #"\n"
0 0 17 3 37 #";                     (interp a env))"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";                    (closV-env f-value))))]"
0 0 22 29 1 #"\n"
0 0 17 3 55 #";    [plusC (l r) (num+ (interp l env) (interp r env))]"
0 0 22 29 1 #"\n"
0 0 17 3 55 #";    [multC (l r) (num* (interp l env) (interp r env))]"
0 0 22 29 1 #"\n"
0 0 17 3 123
(
 #";    ;[fdC (f a b) (funV f a b)] ;A function is inherently anonymous"
 #", and we should separate its definition from its naming"
) 0 0 22 29 1 #"\n"
0 0 17 3 35 #";    [lamC (a b) (closV a b env)]))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";;; use with without closV and lamC"
0 0 22 29 1 #"\n"
0 0 17 3 77
(
 #";;(test (interp (plusC (numC 10) (appC (fdC 'const5 '_ (numC 5)) (nu"
 #"mC 10))) "
) 0 0 22 29 1 #"\n"
0 0 17 3 27 #";;              empty-env) "
0 0 22 29 1 #"\n"
0 0 17 3 19 #";;      (numV 15)) "
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 83
(
 #";;(test/exn (interp (appC (fdC 'f1 'x (appC (fdC 'f2 'y (plusC (idC "
 #"'x) (idC 'y))) "
) 0 0 22 29 1 #"\n"
0 0 17 3 55 #";;                                          (numC 4))) "
0 0 22 29 1 #"\n"
0 0 17 3 36 #";;                        (numC 3)) "
0 0 22 29 1 #"\n"
0 0 17 3 31 #";;                  empty-env) "
0 0 22 29 1 #"\n"
0 0 17 3 44 #";;          \"lookup: symbol not found: 'x\") "
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";;(define nested-fdC (fdC 'f1 'x "
0 0 22 29 1 #"\n"
0 0 17 3 38 #";;                        (fdC 'f2 'x "
0 0 22 29 1 #"\n"
0 0 17 3 59
#";;                             (plusC (idC 'x) (idC 'x)))))"
0 0 22 29 1 #"\n"
0 0 17 3 27 #";;(test (interp  nested-fdC"
0 0 22 29 1 #"\n"
0 0 17 3 81
(
 #";;               empty-env) (funV 'f1 'x (fdC 'f2 'x (plusC (idC 'x)"
 #" (idC 'x)))))"
) 0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";;(test (interp  (appC nested-fdC "
0 0 22 29 1 #"\n"
0 0 17 3 33 #";;                     (numC 4)) "
0 0 22 29 1 #"\n"
0 0 17 3 68
#";;               empty-env) (funV 'f2 'x (plusC (idC 'x) (idC 'x))))"
0 0 22 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 22 29 1 #"\n"
0 0 17 3 356
(
 #";;;we\342\200\231re again failing to faithfully capture what substit"
 #"ution would have done. A function value needs to remember the substi"
 #"tutions that have already been applied to it. Because we\342\200\231"
 #"re representing substitutions using an environment, a function value"
 #" therefore needs to be bundled with an environment. This resulting d"
 #"ata structure is called a closure."
) 0 0 22 29 1 #"\n"
0 0 17 3 39 #";;; this fails (when using fdC and funV"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";;(test/exn (interp (appC (appC (fdC 'f1 'x "
0 0 22 29 1 #"\n"
0 0 17 3 49 #";;                                   (fdC 'f2 'y "
0 0 22 29 1 #"\n"
0 0 17 3 70
(
 #";;                                        (plusC (idC 'x) (idC 'y)))"
 #") "
) 0 0 22 29 1 #"\n"
0 0 17 3 42 #";;                              (numC 4)) "
0 0 22 29 1 #"\n"
0 0 17 3 36 #";;                        (numC 5)) "
0 0 22 29 1 #"\n"
0 0 17 3 62
#";;                  empty-env) \"lookup: symbol not found: 'x\")"
0 0 22 29 1 #"\n"
0 0 17 3 18 #";; but this works:"
0 0 22 29 1 #"\n"
0 0 17 3 11 #";;((\316\273 (x) "
0 0 22 29 1 #"\n"
0 0 17 3 14 #";;   ((\316\273 (y) "
0 0 22 29 1 #"\n"
0 0 17 3 17 #";;      (+ x y)) "
0 0 22 29 1 #"\n"
0 0 17 3 10 #";;    4)) "
0 0 22 29 1 #"\n"
0 0 17 3 5 #";; 5)"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 17 #";;; did not work:"
0 0 22 29 1 #"\n"
0 0 17 3 95
(
 #";;But one moment. What happens if we try the same example in our env"
 #"ironment-based interpreter?"
) 0 0 22 29 1 #"\n"
0 0 17 3 9 #";;Do Now!"
0 0 22 29 1 #"\n"
0 0 17 3 138
(
 #";;Observe that it works correctly: it reports an unbound identifier "
 #"error. Environments automatically implement capture-free substitutio"
 #"n!"
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 110
(
 #";(define subst-again (appC (lamC 'f (lamC 'x (appC (idC 'f) (numC 10"
 #")))) (lamC 'y (plusC (idC 'x) (idC 'y)))))"
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 17 3 3 #";;;"
0 0 22 29 1 #"\n"
0 0 17 3 14 #";;;; Chapter 6"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";(define-type Binding"
0 0 22 29 1 #"\n"
0 0 17 3 41 #";  [bind (name : symbol) (val : number)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 41 #";(define-type-alias Env (listof Binding))"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";(define empty-env empty)"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";(define extend-env cons)"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";(define-type ExprC"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [numC (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";  [idC (s : symbol)]"
0 0 22 29 1 #"\n"
0 0 17 3 38 #";  [appC (fun : symbol) (arg : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";  [plusC (l : ExprC) (r : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";  [multC (l : ExprC) (r : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";  )"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";(define-type FunDefC"
0 0 22 29 1 #"\n"
0 0 17 3 55 #";  [fdC (name : symbol) (arg : symbol) (body : ExprC)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 72
(
 #";(define (get-fun-def [fun : symbol] [fds : (listof FunDefC)]) : Fun"
 #"DefC"
) 0 0 22 29 1 #"\n"
0 0 17 3 19 #";  (if (empty? fds)"
0 0 22 29 1 #"\n"
0 0 17 3 98
(
 #";      (error 'get-fun-def (string-append \"ERR: function definition"
 #" NOT found: \" (to-string fun)))"
) 0 0 22 29 1 #"\n"
0 0 17 3 46 #";      (if (equal? fun (fdC-name (first fds)))"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";          (first fds)"
0 0 22 29 1 #"\n"
0 0 17 3 42 #";          (get-fun-def fun (rest fds)))))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 51 #";(define (lookup [s : symbol] [env : Env]) : number"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";  (if (empty? env)"
0 0 22 29 1 #"\n"
0 0 17 3 80
(
 #";      (error 'lookup (string-append \"ERR: unbound identifier: \" ("
 #"to-string s)))"
) 0 0 22 29 1 #"\n"
0 0 17 3 45 #";      (if (equal? s (bind-name (first env)))"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";          (bind-val (first env))"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";          (lookup s (rest env)))))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 75
(
 #";(define (interp [e : ExprC] [env : Env] [fds : (listof FunDefC)]) :"
 #" number"
) 0 0 22 29 1 #"\n"
0 0 17 3 21 #";  (type-case ExprC e"
0 0 22 29 1 #"\n"
0 0 17 3 17 #";    [numC (n) n]"
0 0 22 29 1 #"\n"
0 0 17 3 60
#";    [plusC (l r) (+ (interp l env fds) (interp r env fds))]"
0 0 22 29 1 #"\n"
0 0 17 3 60
#";    [multC (l r) (* (interp l env fds) (interp r env fds))]"
0 0 22 29 1 #"\n"
0 0 17 3 29 #";    [idC (s) (lookup s env)]"
0 0 22 29 1 #"\n"
0 0 17 3 121
(
 #";; This version will cause the following (test/exn) to fail since th"
 #"e env keeps growing and doesn't handle scope properly"
) 0 0 22 29 1 #"\n"
0 0 17 3 58
#";;    [appC (f a) (local ([define fd (get-fun-def f fds)])"
0 0 22 29 1 #"\n"
0 0 17 3 42 #";;                  (interp (fdC-body fd) "
0 0 22 29 1 #"\n"
0 0 17 3 40 #";;                          (extend-env "
0 0 22 29 1 #"\n"
0 0 17 3 68
#";;                           (bind (fdC-arg fd) (interp a env fds)) "
0 0 22 29 1 #"\n"
0 0 17 3 34 #";;                           env) "
0 0 22 29 1 #"\n"
0 0 17 3 34 #";;                          fds))]"
0 0 22 29 1 #"\n"
0 0 17 3 57 #";    [appC (f a) (local ([define fd (get-fun-def f fds)])"
0 0 22 29 1 #"\n"
0 0 17 3 41 #";                  (interp (fdC-body fd) "
0 0 22 29 1 #"\n"
0 0 17 3 39 #";                          (extend-env "
0 0 22 29 1 #"\n"
0 0 17 3 67
#";                           (bind (fdC-arg fd) (interp a env fds)) "
0 0 22 29 1 #"\n"
0 0 17 3 39 #";                           empty-env) "
0 0 22 29 1 #"\n"
0 0 17 3 33 #";                          fds))]"
0 0 22 29 1 #"\n"
0 0 17 3 7 #";    ))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 58
#";(test (interp (plusC (numC 10) (appC 'const5 (numC 10))) "
0 0 22 29 1 #"\n"
0 0 17 3 25 #";              empty-env "
0 0 22 29 1 #"\n"
0 0 17 3 49 #";              (list (fdC 'const5 '_ (numC 5)))) "
0 0 22 29 1 #"\n"
0 0 17 3 11 #";      15) "
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 74
(
 #";(test (interp (plusC (numC 10) (appC 'double (plusC (numC 1) (numC "
 #"2)))) "
) 0 0 22 29 1 #"\n"
0 0 17 3 25 #";              empty-env "
0 0 22 29 1 #"\n"
0 0 17 3 66
#";              (list (fdC 'double 'x (plusC (idC 'x) (idC 'x))))) "
0 0 22 29 1 #"\n"
0 0 17 3 11 #";      16) "
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 77
(
 #";(test (interp (plusC (numC 10) (appC 'quadruple (plusC (numC 1) (nu"
 #"mC 2)))) "
) 0 0 22 29 1 #"\n"
0 0 17 3 25 #";              empty-env "
0 0 22 29 1 #"\n"
0 0 17 3 80
(
 #";              (list (fdC 'quadruple 'x (appC 'double (appC 'double "
 #"(idC 'x)))) "
) 0 0 22 29 1 #"\n"
0 0 17 3 66
#";                    (fdC 'double 'x (plusC (idC 'x) (idC 'x))))) "
0 0 22 29 1 #"\n"
0 0 17 3 11 #";      22) "
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 39 #";(test/exn (interp (appC 'f1 (numC 3)) "
0 0 22 29 1 #"\n"
0 0 17 3 29 #";                  empty-env "
0 0 22 29 1 #"\n"
0 0 17 3 58
#";                  (list (fdC 'f1 'x (appC 'f2 (numC 4))) "
0 0 22 29 1 #"\n"
0 0 17 3 65
#";                        (fdC 'f2 'y (plusC (idC 'x) (idC 'y)))))"
0 0 22 29 1 #"\n"
0 0 17 3 49 #";          \"lookup: ERR: unbound identifier: 'x\")"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 86
(
 #";;; type in interaction window and huh?? how come z is bound to the "
 #"first value of y??"
) 0 0 22 29 1 #"\n"
0 0 17 3 15 #";;(define y 1) "
0 0 22 29 1 #"\n"
0 0 17 3 39 #";;(define f (let ((z y)) (\316\273 (x) (begin"
0 0 22 29 1 #"\n"
0 0 17 3 59
#";;                                  (display (to-string x))"
0 0 22 29 1 #"\n"
0 0 17 3 59
#";;                                  (display (to-string y))"
0 0 22 29 1 #"\n"
0 0 17 3 59
#";;                                  (display (to-string z))"
0 0 22 29 1 #"\n"
0 0 17 3 54 #";;                                  (+ x (+ y z)))))) "
0 0 22 29 1 #"\n"
0 0 17 3 14 #";;(define y 2)"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 14 #";;;; Chapter 5"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 19 #";(define-type ExprC"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [numC (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";  [idC (s : symbol)]"
0 0 22 29 1 #"\n"
0 0 17 3 38 #";  [appC (fun : symbol) (arg : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";  [plusC (l : ExprC) (r : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";  [multC (l : ExprC) (r : ExprC)]"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";  )"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";(define-type FunDefC"
0 0 22 29 1 #"\n"
0 0 17 3 55 #";  [fdC (name : symbol) (arg : symbol) (body : ExprC)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 72
(
 #";(define (get-fun-def [fun : symbol] [fds : (listof FunDefC)]) : Fun"
 #"DefC"
) 0 0 22 29 1 #"\n"
0 0 17 3 19 #";  (if (empty? fds)"
0 0 22 29 1 #"\n"
0 0 17 3 98
(
 #";      (error 'get-fun-def (string-append \"ERR: function definition"
 #" NOT found: \" (to-string fun)))"
) 0 0 22 29 1 #"\n"
0 0 17 3 46 #";      (if (equal? fun (fdC-name (first fds)))"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";          (first fds)"
0 0 22 29 1 #"\n"
0 0 17 3 42 #";          (get-fun-def fun (rest fds)))))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 93
(
 #";(define (subst [actual-param : ExprC] [formal-param : symbol] [in-f"
 #"un-body : ExprC]) : ExprC"
) 0 0 22 29 1 #"\n"
0 0 17 3 31 #";  (type-case ExprC in-fun-body"
0 0 22 29 1 #"\n"
0 0 17 3 24 #";    [numC (n) (numC n)]"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";    [idC (s) (cond "
0 0 22 29 1 #"\n"
0 0 17 3 56 #";               [(symbol=? s formal-param) actual-param]"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";               [else in-fun-body])]"
0 0 22 29 1 #"\n"
0 0 17 3 62
#";    [appC (f a) (appC f (subst actual-param formal-param a))]"
0 0 22 29 1 #"\n"
0 0 17 3 98
(
 #";    [plusC (l r) (plusC (subst actual-param formal-param l) (subst "
 #"actual-param formal-param r))]"
) 0 0 22 29 1 #"\n"
0 0 17 3 100
(
 #";    [multC (l r) (multC (subst actual-param formal-param l) (subst "
 #"actual-param formal-param r))]))"
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 100
(
 #";(define (subst-eager [actual-param : number] [formal-param : symbol"
 #"] [in-fun-body : ExprC]) : ExprC"
) 0 0 22 29 1 #"\n"
0 0 17 3 31 #";  (type-case ExprC in-fun-body"
0 0 22 29 1 #"\n"
0 0 17 3 24 #";    [numC (n) (numC n)]"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";    [idC (s) (cond "
0 0 22 29 1 #"\n"
0 0 17 3 63
#";               [(symbol=? s formal-param) (numC actual-param)]"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";               [else in-fun-body])]"
0 0 22 29 1 #"\n"
0 0 17 3 68
#";    [appC (f a) (appC f (subst-eager actual-param formal-param a))]"
0 0 22 29 1 #"\n"
0 0 17 3 110
(
 #";    [plusC (l r) (plusC (subst-eager actual-param formal-param l) ("
 #"subst-eager actual-param formal-param r))]"
) 0 0 22 29 1 #"\n"
0 0 17 3 112
(
 #";    [multC (l r) (multC (subst-eager actual-param formal-param l) ("
 #"subst-eager actual-param formal-param r))]))"
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 63
#";(define (interp [e : ExprC] [fds : (listof FunDefC)]) : number"
0 0 22 29 1 #"\n"
0 0 17 3 21 #";  (type-case ExprC e"
0 0 22 29 1 #"\n"
0 0 17 3 17 #";    [numC (n) n]"
0 0 22 29 1 #"\n"
0 0 17 3 80
(
 #";    [idC (s) (error 'interp (string-append \"ERR: unbound id: \" (t"
 #"o-string s)))]"
) 0 0 22 29 1 #"\n"
0 0 17 3 20 #";    ;; lazy version"
0 0 22 29 1 #"\n"
0 0 17 3 58
#";    ;[appC (f a) (local ([define fd (get-fun-def f fds)])"
0 0 22 29 1 #"\n"
0 0 17 3 71
(
 #";    ;              (interp (subst a (fdC-arg fd) (fdC-body fd)) fds"
 #"))]"
) 0 0 22 29 1 #"\n"
0 0 17 3 57 #";    [appC (f a) (local ([define fd (get-fun-def f fds)])"
0 0 22 29 1 #"\n"
0 0 17 3 90
(
 #";                  (interp (subst (numC (interp a fds)) (fdC-arg fd)"
 #" (fdC-body fd)) fds))]"
) 0 0 22 29 1 #"\n"
0 0 17 3 52 #";    [plusC (l r) (+ (interp l fds) (interp r fds))]"
0 0 22 29 1 #"\n"
0 0 17 3 52 #";    [multC (l r) (* (interp l fds) (interp r fds))]"
0 0 22 29 1 #"\n"
0 0 17 3 5 #";    "
0 0 22 29 1 #"\n"
0 0 17 3 7 #";    ))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";;================================="
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";(define-type ArithC"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [numC (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";  [plusC (l : ArithC) (r : ArithC)]"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";  [multC (l : ArithC) (r : ArithC)]"
0 0 22 29 1 #"\n"
0 0 17 3 74
(
 #";  [if0C (test-expr : ArithC) (true-expr : ArithC) (false-expr : Ari"
 #"thC)])"
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";(define-type ArithS"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [numS (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";  [plusS (l : ArithS) (r : ArithS)]"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";  [multS (l : ArithS) (r : ArithS)]"
0 0 22 29 1 #"\n"
0 0 17 3 38 #";  [bminusS (l : ArithS) (r : ArithS)]"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";  [uminusS (e : ArithS)]"
0 0 22 29 1 #"\n"
0 0 17 3 74
(
 #";  [if0S (test-expr : ArithS) (true-expr : ArithS) (false-expr : Ari"
 #"thS)])"
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 45 #";(define (parseS [s : s-expression]) : ArithS"
0 0 22 29 1 #"\n"
0 0 17 3 8 #";  (cond"
0 0 22 29 1 #"\n"
0 0 17 3 49 #";    [(s-exp-number? s) (numS (s-exp->number s))]"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";    [(s-exp-list? s) "
0 0 22 29 1 #"\n"
0 0 17 3 33 #";     (let ([s1 (s-exp->list s)])"
0 0 22 29 1 #"\n"
0 0 17 3 14 #";       (cond "
0 0 22 29 1 #"\n"
0 0 17 3 29 #";         [(= (length s1) 2) "
0 0 22 29 1 #"\n"
0 0 17 3 43 #";          (case (s-exp->symbol (first s1))"
0 0 22 29 1 #"\n"
0 0 17 3 49 #";            [(-) (uminusS (parseS (second s1)))]"
0 0 22 29 1 #"\n"
0 0 17 3 62
#";            [else (error 'parseS \"unknown unary operator\")])]"
0 0 22 29 1 #"\n"
0 0 17 3 28 #";         [(= (length s1) 3)"
0 0 22 29 1 #"\n"
0 0 17 3 43 #";          (case (s-exp->symbol (first s1))"
0 0 22 29 1 #"\n"
0 0 17 3 67
#";            [(+) (plusS (parseS (second s1)) (parseS (third s1)))]"
0 0 22 29 1 #"\n"
0 0 17 3 67
#";            [(*) (multS (parseS (second s1)) (parseS (third s1)))]"
0 0 22 29 1 #"\n"
0 0 17 3 69
(
 #";            [(-) (bminusS (parseS (second s1)) (parseS (third s1)))"
 #"]"
) 0 0 22 29 1 #"\n"
0 0 17 3 62
#";            [else (error 'parse \"unknown binary operator\")])]"
0 0 22 29 1 #"\n"
0 0 17 3 28 #";         [(= (length s1) 4)"
0 0 22 29 1 #"\n"
0 0 17 3 43 #";          (case (s-exp->symbol (first s1))"
0 0 22 29 1 #"\n"
0 0 17 3 89
(
 #";            [(if0) (if0S (parseS (second s1)) (parseS (third s1)) ("
 #"parseS (fourth s1)))]"
) 0 0 22 29 1 #"\n"
0 0 17 3 61
#";            [else (error 'parseS \"unknown quad operator\")])]"
0 0 22 29 1 #"\n"
0 0 17 3 107
(
 #";         [else (error 'parseS (string-append \"unknown number of op"
 #"erators: \" (to-string (length s1))))]))]"
) 0 0 22 29 1 #"\n"
0 0 17 3 50 #";    [else (error 'parseS \"invalid expression\")]))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 39 #";(define (interp [a : ArithC]) : number"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  (type-case ArithC a"
0 0 22 29 1 #"\n"
0 0 17 3 17 #";    [numC (n) n]"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";    [plusC (l r) (+ (interp l) (interp r))]"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";    [multC (l r) (* (interp l) (interp r))]"
0 0 22 29 1 #"\n"
0 0 17 3 65
#";    [if0C (a b c) (if (= 0 (interp a)) (interp b) (interp c))]))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 40 #";(define (desugar [a : ArithS]) : ArithC"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  (type-case ArithS a"
0 0 22 29 1 #"\n"
0 0 17 3 24 #";    [numS (n) (numC n)]"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";    [plusS (l r) (plusC (desugar l) (desugar r))]"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";    [multS (l r) (multC (desugar l) (desugar r))]"
0 0 22 29 1 #"\n"
0 0 17 3 70
(
 #";    [bminusS (l r) (plusC (desugar l) (multC (numC -1) (desugar r))"
 #")]"
) 0 0 22 29 1 #"\n"
0 0 17 3 48 #";    [uminusS (e) (multC (numC -1) (desugar e))]"
0 0 22 29 1 #"\n"
0 0 17 3 64
#";    [if0S (a b c) (if0C (desugar a) (desugar b) (desugar c))]))"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 14 #";;;; Chapter 4"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";(define-type ArithC"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [numC (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";  [plusC (l : ArithC) (r : ArithC)]"
0 0 22 29 1 #"\n"
0 0 17 3 37 #";  [multC (l : ArithC) (r : ArithC)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";(define-type ArithS"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [numS (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";  [plusS (l : ArithS) (r : ArithS)]"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";  [multS (l : ArithS) (r : ArithS)]"
0 0 22 29 1 #"\n"
0 0 17 3 38 #";  [bminusS (l : ArithS) (r : ArithS)]"
0 0 22 29 1 #"\n"
0 0 17 3 26 #";  [uminusS (e : ArithS)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 41 #";(define (desugar [as : ArithS]) : ArithC"
0 0 22 29 1 #"\n"
0 0 17 3 23 #";  (type-case ArithS as"
0 0 22 29 1 #"\n"
0 0 17 3 24 #";    [numS (n) (numC n)]"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";    [plusS (l r) (plusC (desugar l) (desugar r))]"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";    [multS (l r) (multC (desugar l) (desugar r))]"
0 0 22 29 1 #"\n"
0 0 17 3 70
(
 #";    [bminusS (l r) (plusC (desugar l) (multC (numC -1) (desugar r))"
 #")]"
) 0 0 22 29 1 #"\n"
0 0 17 3 50 #";    ;[uminusS (e) (desugar (bminusS (numS 0) e))]"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";    ;[uminusS (e) (bminusS (numS 0) (desugar e))]"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";    [uminusS (e) (multC (numC -1) (desugar e))]))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 45 #";(define (parseS [s : s-expression]) : ArithS"
0 0 22 29 1 #"\n"
0 0 17 3 8 #";  (cond"
0 0 22 29 1 #"\n"
0 0 17 3 49 #";    [(s-exp-number? s) (numS (s-exp->number s))]"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";    [(s-exp-list? s) "
0 0 22 29 1 #"\n"
0 0 17 3 33 #";     (let ([s1 (s-exp->list s)])"
0 0 22 29 1 #"\n"
0 0 17 3 14 #";       (cond "
0 0 22 29 1 #"\n"
0 0 17 3 29 #";         [(= (length s1) 2) "
0 0 22 29 1 #"\n"
0 0 17 3 43 #";          (case (s-exp->symbol (first s1))"
0 0 22 29 1 #"\n"
0 0 17 3 49 #";            [(-) (uminusS (parseS (second s1)))]"
0 0 22 29 1 #"\n"
0 0 17 3 62
#";            [else (error 'parseS \"unknown unary operator\")])]"
0 0 22 29 1 #"\n"
0 0 17 3 28 #";         [(= (length s1) 3)"
0 0 22 29 1 #"\n"
0 0 17 3 43 #";          (case (s-exp->symbol (first s1))"
0 0 22 29 1 #"\n"
0 0 17 3 67
#";            [(+) (plusS (parseS (second s1)) (parseS (third s1)))]"
0 0 22 29 1 #"\n"
0 0 17 3 67
#";            [(*) (multS (parseS (second s1)) (parseS (third s1)))]"
0 0 22 29 1 #"\n"
0 0 17 3 69
(
 #";            [(-) (bminusS (parseS (second s1)) (parseS (third s1)))"
 #"]"
) 0 0 22 29 1 #"\n"
0 0 17 3 62
#";            [else (error 'parse \"unknown binary operator\")])]"
0 0 22 29 1 #"\n"
0 0 17 3 64
#";         [else (error 'parseS \"unkown number of operators\")]))]"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";    [else (error 'parseS \"invalid expression\")]))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 39 #";(define (interp [a : ArithC]) : number"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  (type-case ArithC a"
0 0 22 29 1 #"\n"
0 0 17 3 17 #";    [numC (n) n]"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";    [plusC (l r) (+ (interp l) (interp r))]"
0 0 22 29 1 #"\n"
0 0 17 3 46 #";    [multC (l r) (* (interp l) (interp r))]))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 47 #";(test (interp (desugar (parseS '(- 40)))) -40)"
0 0 22 29 1 #"\n"
0 0 17 3 64
#";(test (interp (desugar (parseS '(- (* (- 9 4) (+ 2 6)))))) -40)"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 14 #";;;; Chapter 3"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";(define-type ArithC"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [numC (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";  [plusC (l : ArithC) (r : ArithC)]"
0 0 22 29 1 #"\n"
0 0 17 3 37 #";  [multC (l : ArithC) (r : ArithC)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 39 #";(define (interp [a : ArithC]) : number"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  (type-case ArithC a"
0 0 22 29 1 #"\n"
0 0 17 3 17 #";    [numC (n) n]"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";    [plusC (l r) (+ (interp l) (interp r))]"
0 0 22 29 1 #"\n"
0 0 17 3 46 #";    [multC (l r) (* (interp l) (interp r))]))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";(define (parse [s : s-expression]) : ArithC"
0 0 22 29 1 #"\n"
0 0 17 3 8 #";  (cond"
0 0 22 29 1 #"\n"
0 0 17 3 49 #";    [(s-exp-number? s) (numC (s-exp->number s))]"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";    [(s-exp-list? s) "
0 0 22 29 1 #"\n"
0 0 17 3 33 #";     (let ([s1 (s-exp->list s)])"
0 0 22 29 1 #"\n"
0 0 17 3 40 #";       (case (s-exp->symbol (first s1))"
0 0 22 29 1 #"\n"
0 0 17 3 62
#";         [(+) (plusC (parse (second s1)) (parse (third s1)))]"
0 0 22 29 1 #"\n"
0 0 17 3 62
#";         [(*) (multC (parse (second s1)) (parse (third s1)))]"
0 0 22 29 1 #"\n"
0 0 17 3 55 #";         [else (error 'parse \"invalid list input\")]))]"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";    [else (error 'parse \"invalid input\")]))"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 17 3 3 #";;;"
0 0 22 29 1 #"\n"
0 0 17 3 14 #";;;; Chapter 2"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";(define l '(+ 1 2))"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";(define f (first (s-exp->list l)))"
0 0 22 29 1 #"\n"
0 0 17 3 52 #";(define f1 (s-exp->symbol (first (s-exp->list l))))"
0 0 22 29 1 #"\n"
0 0 17 3 53 #";(define f2 (s-exp->number (second (s-exp->list l))))"
0 0 22 29 1 #"\n"
0 0 17 3 52 #";(define f3 (s-exp->number (third (s-exp->list l))))"
0 0 22 29 1 #"\n"
0 0 17 3 69
(
 #";(define f-1 (symbol->string(s-exp->symbol (first (s-exp->list l))))"
 #")"
) 0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 20 #";(define-type ArithC"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";  [numC (n : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 36 #";  [plusC (l : ArithC) (r : ArithC)]"
0 0 22 29 1 #"\n"
0 0 17 3 37 #";  [multC (l : ArithC) (r : ArithC)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 23 #";(define a-1 (numC 23))"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";(define a-2 '(+ 2 4))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";(define (parse [s : s-expression]) : ArithC"
0 0 22 29 1 #"\n"
0 0 17 3 8 #";  (cond"
0 0 22 29 1 #"\n"
0 0 17 3 49 #";    [(s-exp-number? s) (numC (s-exp->number s))]"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";    [(s-exp-list? s) "
0 0 22 29 1 #"\n"
0 0 17 3 33 #";     (let ([s1 (s-exp->list s)])"
0 0 22 29 1 #"\n"
0 0 17 3 40 #";       (case (s-exp->symbol (first s1))"
0 0 22 29 1 #"\n"
0 0 17 3 62
#";         [(+) (plusC (parse (second s1)) (parse (third s1)))]"
0 0 22 29 1 #"\n"
0 0 17 3 62
#";         [(*) (multC (parse (second s1)) (parse (third s1)))]"
0 0 22 29 1 #"\n"
0 0 17 3 55 #";         [else (error 'parse \"invalid list input\")]))]"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";    [else (error 'parse \"invalid input\")]))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 10 #";(parse l)"
0 0 22 29 1 #"\n"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 14 #";;;; Chapter 1"
0 0 22 29 1 #"\n"
0 0 17 3 4 #";;;;"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 30 #";(define-type MisspelledAnimal"
0 0 22 29 1 #"\n"
0 0 17 3 26 #";  [caml (humps : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 28 #";  [yacc (height : number)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 42 #";(define ma-1 : MisspelledAnimal (caml 3))"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";(define ma-2 : MisspelledAnimal (yacc 4.9))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 22 #";(define ma1 (caml 3))"
0 0 22 29 1 #"\n"
0 0 17 3 24 #";(define ma2 (yacc 2.7))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 50 #";(define (good? [ma : MisspelledAnimal]) : boolean"
0 0 22 29 1 #"\n"
0 0 17 3 33 #";  (type-case MisspelledAnimal ma"
0 0 22 29 1 #"\n"
0 0 17 3 32 #";    [caml (humps) (>= humps 2)]"
0 0 22 29 1 #"\n"
0 0 17 3 37 #";    [yacc (height) (> height 2.1)]))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;(test (good? ma1) #t)"
0 0 22 29 1 #"\n"
0 0 17 3 23 #";;(test (good? ma2) #t)"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 32 #";(define-type MisspelledAnimal-2"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";  [caml2 (humps-of-caml : number)]"
0 0 22 29 1 #"\n"
0 0 17 3 37 #";  [yacc2 (height-of-yacc : number)])"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 53 #";(define (good2? [ma : MisspelledAnimal-2]) : boolean"
0 0 22 29 1 #"\n"
0 0 17 3 35 #";  (type-case MisspelledAnimal-2 ma"
0 0 22 29 1 #"\n"
0 0 17 3 37 #";    [yacc2 (height) (>= height 2.1)]"
0 0 22 29 1 #"\n"
0 0 17 3 34 #";    [caml2 (humps) (> humps 2)]))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 45 #";(define ma-3 : MisspelledAnimal-2 (caml2 1))"
0 0 22 29 1 #"\n"
0 0 17 3 47 #";(define ma-4 : MisspelledAnimal-2 (yacc2 2.1))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";;(test (good2? ma-4) #t)"
0 0 22 29 1 #"\n"
0 0 17 3 25 #";;(test (good2? ma-3) #f)"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 51 #";(define (good3? [ma : MisspelledAnimal]) : boolean"
0 0 22 29 1 #"\n"
0 0 17 3 8 #";  (cond"
0 0 22 29 1 #"\n"
0 0 17 3 40 #";    [(caml? ma) (>= (caml-humps ma) 1)]"
0 0 22 29 1 #"\n"
0 0 17 3 44 #";    [(yacc? ma) (> (yacc-height ma) 2.1)]))"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0 0 17 3 24 #";;(test (good3? ma1) #t)"
0 0 22 29 1 #"\n"
0 0 17 3 24 #";;(test (good3? ma2) #t)"
0 0 22 29 1 #"\n"
0 0 17 3 1 #";"
0 0 22 29 1 #"\n"
0           0
